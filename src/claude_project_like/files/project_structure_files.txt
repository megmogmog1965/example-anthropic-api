//////////////// Project Structure ////////////////

README.md
app/api/auth/change-password/route.ts
app/api/auth/sync-user/route.ts
app/api/goals/approve/route.ts
app/api/goals/route.ts
app/api/organization/confirm/route.ts
app/api/organization/download/route.ts
app/api/organization/structure/route.ts
app/api/organization/upload/route.ts
app/api/users/[id]/route.ts
app/api/users/route.ts
app/favicon.ico
app/globals.css
app/layout.tsx
app/page.tsx
components.json
components/Auth.tsx
components/AuthProvider.tsx
components/CsvUploader.tsx
components/DataPreview.tsx
components/GoalDetails.tsx
components/GoalEditForm.tsx
components/GoalForm.tsx
components/GoalList.tsx
components/GoalListHeader.tsx
components/GoalReviewList.tsx
components/Header.tsx
components/NewGoalForm.tsx
components/OrganizationChart.tsx
components/OrganizationStructure.tsx
components/PasswordChangeForm.tsx
components/UserInfo.tsx
components/UserTable.tsx
components/custom/FileInput.tsx
components/custom/Steps.tsx
components/ui/alert.tsx
components/ui/badge.tsx
components/ui/button.tsx
components/ui/card.tsx
components/ui/input.tsx
components/ui/label.tsx
components/ui/select.tsx
components/ui/table.tsx
components/ui/textarea.tsx
docs/コミュニケーション機能を強化した目標設定プロセスのユーザーフロー図.mermaid
docs/要件定義書.md
lib/prisma.ts
lib/supabase/client.ts
lib/supabase/middleware.ts
lib/supabase/server.ts
lib/translations.ts
lib/utils.ts
middleware.ts
next-env.d.ts
next.config.mjs
package-lock.json
package.json
postcss.config.mjs
prisma/migrations/20240830114122_init/migration.sql
prisma/migrations/20240902082841_add_user_role/migration.sql
prisma/migrations/20240902083449_add_goal_approval_flow/migration.sql
prisma/migrations/20240903123924_add_organization_structure/migration.sql
prisma/migrations/20240904110214_add_quarter_and_year_to_goals/migration.sql
prisma/migrations/20240904110452_manual_20240904200445/migration.sql
prisma/migrations/20240904115758_multi_feedbacks/migration.sql
prisma/migrations/20240904135546_update_goal_structure/migration.sql
prisma/migrations/migration_lock.toml
prisma/schema.prisma
public/next.svg
public/vercel.svg
tailwind.config.ts
tsconfig.json
types/index.ts

//////////////// FILE: README.md ////////////////

This is a [Next.js](https://nextjs.org/) project bootstrapped with [`create-next-app`](https://github.com/vercel/next.js/tree/canary/packages/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/basic-features/font-optimization) to automatically optimize and load Inter, a custom Google Font.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js/) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/deployment) for more details.


//////////////// FILE: app/api/auth/change-password/route.ts ////////////////

// app/api/auth/change-password/route.ts

import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'

const PASSWORD_MIN_LENGTH = 8

function validatePassword(password: string): boolean {
  return password.length >= PASSWORD_MIN_LENGTH &&
         /[A-Z]/.test(password) &&
         /[a-z]/.test(password) &&
         /[0-9]/.test(password) &&
         /[^A-Za-z0-9]/.test(password)
}

export async function POST(request: NextRequest) {
  const body = await request.json()
  const { currentPassword, newPassword } = body
  const supabase = createClient()

  if (!currentPassword || !newPassword) {
    return NextResponse.json({ message: '現在のパスワードと新しいパスワードが必要です。' }, { status: 400 })
  }

  try {
    const { data: { user } } = await supabase.auth.getUser()

    if (!user) {
      return NextResponse.json({ message: 'ユーザーが見つかりません。' }, { status: 401 })
    }

    // 現在のパスワードを確認
    const { error: signInError } = await supabase.auth.signInWithPassword({
      email: user.email!,
      password: currentPassword,
    })

    if (signInError) {
      return NextResponse.json({ message: '現在のパスワードが正しくありません。' }, { status: 400 })
    }

    // パスワードを更新
    const { error: updateError } = await supabase.auth.updateUser({ password: newPassword })

    if (updateError) {
      console.error('パスワード更新エラー:', updateError)
      return NextResponse.json({ message: 'パスワードの更新に失敗しました。しばらくしてから再度お試しください。' }, { status: 500 })
    }

    return NextResponse.json({ message: 'パスワードが正常に更新されました。' }, { status: 200 })
  } catch (error) {
    console.error('パスワード変更中にエラーが発生しました:', error)
    return NextResponse.json({ message: 'パスワードの変更中にエラーが発生しました。しばらくしてから再度お試しください。' }, { status: 500 })
  }
}

//////////////// FILE: app/api/auth/sync-user/route.ts ////////////////

// app/api/auth/sync-user/route.ts

import { NextRequest, NextResponse } from 'next/server'
import prisma from '@/lib/prisma'

export async function POST(request: NextRequest) {
  const body = await request.json()
  const { id, email } = body

  if (!id || !email) {
    return NextResponse.json({ message: 'Invalid request' }, { status: 400 })
  }

  try {
    const existingUser = await prisma.user.findUnique({ where: { id } })

    if (!existingUser) {
      // 新規ユーザーの場合のみ、Prisma User テーブルに追加
      const user = await prisma.user.create({
        data: {
          id,
          email,
          role: 'EMPLOYEE', // デフォルトロールを設定
        },
      })

      return NextResponse.json({ message: 'User synchronized successfully', user }, { status: 200 })
    } else {
      // 既存ユーザーの場合は何もしない
      return NextResponse.json({ message: 'User already exists', user: existingUser }, { status: 200 })
    }
  } catch (error: any) {
    console.error('Error synchronizing user:', error)
    return NextResponse.json({ message: 'Error synchronizing user' }, { status: 500 })
  }
}

//////////////// FILE: app/api/goals/approve/route.ts ////////////////

import { NextRequest, NextResponse } from 'next/server'
import prisma from '@/lib/prisma'
import { GoalStatus } from '@prisma/client'

export async function POST(request: NextRequest) {
  const body = await request.json()
  const { goalId, managerId, status, feedback } = body

  if (!goalId || !managerId || !status) {
    return NextResponse.json({ error: 'Missing required fields' }, { status: 400 })
  }

  try {
    const updatedGoal = await prisma.goal.update({
      where: { id: goalId },
      data: {
        status: status as GoalStatus,
        manager: {
          connect: { id: managerId }
        },
        feedbacks: {
          create: {
            content: feedback || '',
            status: status as GoalStatus,
            userId: managerId
          }
        }
      },
      include: {
        feedbacks: {
          orderBy: {
            createdAt: 'desc'
          }
        },
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    })

    return NextResponse.json(updatedGoal, { status: 200 })
  } catch (error: any) {
    console.error('Error approving goal:', error)
    return NextResponse.json({ error: 'Failed to approve goal' }, { status: 500 })
  }
}

//////////////// FILE: app/api/goals/route.ts ////////////////

import { NextRequest, NextResponse } from 'next/server'
import prisma from '@/lib/prisma'
import { GoalStatus } from '@prisma/client'

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url)
  const userId = searchParams.get('userId')
  const managerId = searchParams.get('managerId')
  const status = searchParams.get('status') as GoalStatus | null

  let goals;

  try {
    if (managerId) {
      goals = await prisma.goal.findMany({
        where: {
          user: {
            managerId: managerId
          },
          status: status || undefined
        },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          },
          feedbacks: {
            orderBy: {
              createdAt: 'desc'
            },
            include: {
              user: {
                select: {
                  id: true,
                  name: true,
                  email: true
                }
              }
            }
          }
        },
        orderBy: [
          { year: 'desc' },
          { quarter: 'desc' }
        ],
      })
    } else if (userId) {
      goals = await prisma.goal.findMany({
        where: { userId: userId },
        include: {
          feedbacks: {
            orderBy: {
              createdAt: 'desc'
            },
            include: {
              user: {
                select: {
                  id: true,
                  name: true,
                  email: true
                }
              }
            }
          }
        },
        orderBy: [
          { year: 'desc' },
          { quarter: 'desc' }
        ],
      })
    } else {
      return NextResponse.json({ error: 'User ID or Manager ID is required' }, { status: 400 })
    }

    return NextResponse.json(goals)
  } catch (error: any) {
    console.error('Error fetching goals:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

export async function POST(request: NextRequest) {
  const body = await request.json()
  const { organizationGoal, performanceRole, performanceCriteria, stretchVision, stretchGap, stretchAction, stretchCriteria, status, userId, quarter, year } = body

  try {
    const existingGoal = await prisma.goal.findFirst({
      where: {
        userId,
        year,
        quarter
      }
    })

    if (existingGoal) {
      return NextResponse.json({ error: 'A goal for this quarter already exists' }, { status: 400 })
    }

    const newGoal = await prisma.goal.create({
      data: {
        organizationGoal,
        performanceRole,
        performanceCriteria,
        stretchVision,
        stretchGap,
        stretchAction,
        stretchCriteria,
        status: status as GoalStatus,
        userId,
        quarter,
        year
      },
    })

    return NextResponse.json(newGoal)
  } catch (error: any) {
    console.error('Error creating goal:', error)
    return NextResponse.json({ error: 'Failed to create goal' }, { status: 500 })
  }
}

export async function PUT(request: NextRequest) {
  const body = await request.json()
  const { id, organizationGoal, performanceRole, performanceCriteria, stretchVision, stretchGap, stretchAction, stretchCriteria, status, quarter, year } = body

  try {
    const updatedGoal = await prisma.goal.update({
      where: { id },
      data: { 
        organizationGoal, 
        performanceRole,
        performanceCriteria,
        stretchVision,
        stretchGap,
        stretchAction,
        stretchCriteria,
        status: status as GoalStatus,
        quarter,
        year
      },
    })
    return NextResponse.json(updatedGoal)
  } catch (error: any) {
    console.error('Error updating goal:', error)
    return NextResponse.json({ error: 'Failed to update goal' }, { status: 500 })
  }
}

export async function DELETE(request: NextRequest) {
  const { searchParams } = new URL(request.url)
  const id = searchParams.get('id')

  if (!id) {
    return NextResponse.json({ error: 'Goal ID is required' }, { status: 400 })
  }

  try {
    await prisma.goal.delete({
      where: { id },
    })
    return NextResponse.json({ message: 'Goal deleted successfully' })
  } catch (error: any) {
    console.error('Error deleting goal:', error)
    return NextResponse.json({ error: 'Failed to delete goal' }, { status: 500 })
  }
}

//////////////// FILE: app/api/organization/confirm/route.ts ////////////////

// app/api/organization/confirm/route.ts

import { NextRequest, NextResponse } from 'next/server'
import prisma from '@/lib/prisma'
import { Role } from '@prisma/client'

type OrganizationUser = {
  organization: string;
  managerEmail: string | null;
  role: Role;
  email: string;
}

export async function POST(request: NextRequest) {
  const body = await request.json()
  const { data } = body as { data: OrganizationUser[] }

  if (!data || !Array.isArray(data)) {
    return NextResponse.json({ message: '無効なデータ形式です' }, { status: 400 })
  }

  try {
    await prisma.$transaction(async (prisma) => {
      for (const user of data) {
        let managerId: string | null = null

        if (user.managerEmail) {
          const manager = await prisma.user.findUnique({
            where: { email: user.managerEmail },
          })
          managerId = manager?.id || null
        }

        const existingUser = await prisma.user.findUnique({
          where: { email: user.email },
        })

        if (existingUser) {
          await prisma.user.update({
            where: { id: existingUser.id },
            data: {
              role: user.role,
              department: user.organization,
              managerId: managerId,
            },
          })
        } else {
          await prisma.user.create({
            data: {
              email: user.email,
              role: user.role,
              department: user.organization,
              managerId: managerId,
            },
          })
        }
      }
    })

    return NextResponse.json({ message: '組織構造が正常に登録されました' })
  } catch (error: any) {
    console.error('組織構造の登録中にエラーが発生しました:', error)
    return NextResponse.json({ message: '組織構造の登録中にエラーが発生しました' }, { status: 500 })
  }
}

//////////////// FILE: app/api/organization/download/route.ts ////////////////

// app/api/organization/download/route.ts

import { NextRequest, NextResponse } from 'next/server'
import prisma from '@/lib/prisma'
import { stringify } from 'csv-stringify/sync'

export async function GET(request: NextRequest) {
  try {
    const users = await prisma.user.findMany({
      include: {
        manager: {
          select: {
            email: true
          }
        }
      }
    })

    const csvData = stringify(users.map(user => ({
      組織: user.department,
      上司: user.manager?.email || '',
      役職: user.role,
      メールアドレス: user.email,
    })), {
      header: true,
      columns: [
        { key: '組織', header: '組織' },
        { key: '上司', header: '上司' },
        { key: '役職', header: '役職（ロール）' },
        { key: 'メールアドレス', header: 'メールアドレス' },
      ],
    })

    return new NextResponse(csvData, {
      status: 200,
      headers: {
        'Content-Type': 'text/csv',
        'Content-Disposition': 'attachment; filename=organization_structure.csv',
      },
    })
  } catch (error: any) {
    console.error('CSV生成中にエラーが発生しました:', error)
    return NextResponse.json({ message: 'CSV生成中にエラーが発生しました' }, { status: 500 })
  }
}

//////////////// FILE: app/api/organization/structure/route.ts ////////////////

import { NextRequest, NextResponse } from 'next/server'
import prisma from '@/lib/prisma'

type Department = {
  name: string;
  users: any[];
  children: Department[];
}

export async function GET(request: NextRequest) {
  try {
    const users = await prisma.user.findMany({
      include: {
        manager: {
          select: {
            email: true
          }
        }
      }
    })

    const organizationStructure: Department = {
      name: 'Root',
      users: [],
      children: []
    }

    users.forEach(user => {
      if (user.department) {
        const departments = user.department.split('/')
        let currentLevel = organizationStructure

        departments.forEach((dept, index) => {
          let existingDept = currentLevel.children.find(d => d.name === dept)
          if (!existingDept) {
            existingDept = { name: dept, users: [], children: [] }
            currentLevel.children.push(existingDept)
          }
          if (index === departments.length - 1) {
            existingDept.users.push(user)
          }
          currentLevel = existingDept
        })
      } else {
        organizationStructure.users.push(user)
      }
    })

    return NextResponse.json(organizationStructure)
  } catch (error: any) {
    console.error('組織構造の取得中にエラーが発生しました:', error)
    return NextResponse.json({ message: '組織構造の取得に失敗しました' }, { status: 500 })
  }
}

//////////////// FILE: app/api/organization/upload/route.ts ////////////////

// app/api/organization/upload/route.ts

import { NextRequest, NextResponse } from 'next/server'
import { parse } from 'csv-parse/sync'
import { Role } from '@prisma/client'

type OrganizationUser = {
  organization: string;
  managerEmail: string | null;
  role: Role;
  email: string;
}

export async function POST(request: NextRequest) {
  const data = await request.formData()
  const file: File | null = data.get('file') as unknown as File

  if (!file) {
    return NextResponse.json({ message: 'ファイルが見つかりません' }, { status: 400 })
  }

  const bytes = await file.arrayBuffer()
  const buffer = Buffer.from(bytes)

  try {
    const records = parse(buffer.toString(), {
      columns: true,
      skip_empty_lines: true,
      trim: true,
    })

    const validatedRecords: OrganizationUser[] = records.map((record: any, index: number) => {
      const organization = record['組織']
      const managerEmail = record['上司']
      const role = record['役職（ロール）']
      const email = record['メールアドレス']

      if (!organization || !role || !email) {
        throw new Error(`行 ${index + 2}: 組織、役職（ロール）、またはメールアドレスが不足しています`)
      }

      const upperCaseRole = role.toUpperCase() as Role
      if (!Object.values(Role).includes(upperCaseRole)) {
        throw new Error(`行 ${index + 2}: 無効なロール: ${role}`)
      }

      return {
        organization,
        managerEmail: managerEmail || null,
        role: upperCaseRole,
        email,
      }
    })

    return NextResponse.json({ data: validatedRecords })
  } catch (error: any) {
    console.error('CSVの解析に失敗しました:', error)
    return NextResponse.json({ message: `CSVの解析に失敗しました: ${error.message}` }, { status: 400 })
  }
}

//////////////// FILE: app/api/users/[id]/route.ts ////////////////

import { NextRequest, NextResponse } from 'next/server'
import prisma from '@/lib/prisma'

export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const id = params.id

  try {
    const user = await prisma.user.findUnique({
      where: { id },
    })

    if (!user) {
      return NextResponse.json({ error: 'User not found' }, { status: 404 })
    }

    return NextResponse.json(user)
  } catch (error: any) {
    console.error('Error fetching user:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

export async function PUT(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const id = params.id
  const body = await request.json()
  const { name } = body

  try {
    const updatedUser = await prisma.user.update({
      where: { id },
      data: { name: name === '' ? null : name },
    })

    return NextResponse.json(updatedUser)
  } catch (error: any) {
    console.error('Error updating user:', error)
    return NextResponse.json({ error: 'Failed to update user' }, { status: 500 })
  }
}

//////////////// FILE: app/api/users/route.ts ////////////////

// app/api/users/route.ts

import { NextRequest, NextResponse } from 'next/server'
import prisma from '@/lib/prisma'

export async function GET(request: NextRequest) {
  try {
    const users = await prisma.user.findMany({
      include: {
        manager: {
          select: {
            id: true,
            name: true,
            email: true,
          },
        },
      },
    })

    return NextResponse.json(users)
  } catch (error: any) {
    console.error('ユーザー情報の取得中にエラーが発生しました:', error)
    return NextResponse.json({ message: 'ユーザー情報の取得に失敗しました' }, { status: 500 })
  }
}

//////////////// FILE: app/globals.css ////////////////

@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;
    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;
    --primary: 222.2 47.4% 11.2%;
    --primary-foreground: 210 40% 98%;
    --secondary: 210 40% 96.1%;
    --secondary-foreground: 222.2 47.4% 11.2%;
    --muted: 210 40% 96.1%;
    --muted-foreground: 215.4 16.3% 46.9%;
    --accent: 210 40% 96.1%;
    --accent-foreground: 222.2 47.4% 11.2%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;
    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --ring: 222.2 84% 4.9%;
    --radius: 0.5rem;
    --chart-1: 12 76% 61%;
    --chart-2: 173 58% 39%;
    --chart-3: 197 37% 24%;
    --chart-4: 43 74% 66%;
    --chart-5: 27 87% 67%;
  }

  .dark {
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;
    --card: 222.2 84% 4.9%;
    --card-foreground: 210 40% 98%;
    --popover: 222.2 84% 4.9%;
    --popover-foreground: 210 40% 98%;
    --primary: 210 40% 98%;
    --primary-foreground: 222.2 47.4% 11.2%;
    --secondary: 217.2 32.6% 17.5%;
    --secondary-foreground: 210 40% 98%;
    --muted: 217.2 32.6% 17.5%;
    --muted-foreground: 215 20.2% 65.1%;
    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%;
    --border: 217.2 32.6% 17.5%;
    --input: 217.2 32.6% 17.5%;
    --ring: 212.7 26.8% 83.9%;
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}

//////////////// FILE: app/layout.tsx ////////////////

import './globals.css'
import type { Metadata } from 'next'
import { AuthProvider } from '@/components/AuthProvider'
import { Header } from '@/components/Header'

export const metadata: Metadata = {
  title: '目標設定アプリ',
  description: '目標を設定し、進捗を追跡するアプリケーション',
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="ja">
      <body className="min-h-screen bg-gray-50">
        <AuthProvider>
          <Header />
          <main className="container mx-auto px-4 py-8">
            {children}
          </main>
        </AuthProvider>
      </body>
    </html>
  )
}

//////////////// FILE: app/page.tsx ////////////////

'use client'

import { Suspense } from 'react'
import GoalList from '@/components/GoalList'
import GoalReviewList from '@/components/GoalReviewList'
import OrganizationStructure from '@/components/OrganizationStructure'
import UserInfo from '@/components/UserInfo'
import { useAuth } from '@/components/AuthProvider'
import { Role } from '@prisma/client'
import Auth from '@/components/Auth'

export default function Home() {
  const { user, loading } = useAuth()

  if (loading) {
    return <div>Loading...</div>
  }

  if (!user) {
    return <Auth />
  }

  return (
    <div className="space-y-6">
      <Suspense fallback={<div>Loading...</div>}>
        <UserInfo />
      </Suspense>
      <Suspense fallback={<div>Loading...</div>}>
        <RoleBasedComponents />
      </Suspense>
    </div>
  )
}

function RoleBasedComponents() {
  const { user } = useAuth()

  if (!user) return null

  return (
    <>
      <Suspense fallback={<div>Loading...</div>}>
        <GoalList />
      </Suspense>
      {user.role === Role.MANAGER && (
        <Suspense fallback={<div>Loading...</div>}>
          <GoalReviewList />
        </Suspense>
      )}
      {user.role === Role.ADMIN && (
        <Suspense fallback={<div>Loading...</div>}>
          <OrganizationStructure />
        </Suspense>
      )}
    </>
  )
}

//////////////// FILE: components.json ////////////////

{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "app/globals.css",
    "baseColor": "slate",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils"
  }
}

//////////////// FILE: components/Auth.tsx ////////////////

"use client"

import { useState } from 'react'
import { createClient } from '@/lib/supabase/client'
import { useAuth } from './AuthProvider'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Badge } from '@/components/ui/badge'
import { Alert, AlertDescription } from "@/components/ui/alert"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import { Role } from '@prisma/client'
import { translateRole } from '@/lib/translations'

// 環境変数または設定ファイルからADMIN作成用のシークレットキーを取得
const ADMIN_SECRET = process.env.NEXT_PUBLIC_ADMIN_SECRET || 'your-admin-secret'

export default function Auth() {
  const [loading, setLoading] = useState(false)
  const [email, setEmail] = useState('')
  const [password, setPassword] = useState('')
  const [role, setRole] = useState<Role>(Role.EMPLOYEE)
  const [isRegistering, setIsRegistering] = useState(false)
  const [message, setMessage] = useState<string | null>(null)
  const [adminSecret, setAdminSecret] = useState('')
  const { user } = useAuth()

  const handleAuth = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault()
    setLoading(true)
    setMessage(null)
    const supabase = createClient()

    try {
      let authResult;
      if (isRegistering) {
        // ADMINロールの場合、シークレットキーを確認
        if (role === Role.ADMIN) {
          if (adminSecret !== ADMIN_SECRET) {
            setMessage("無効な管理者シークレットです。再試行してください。")
            setLoading(false)
            return
          }
        }

        authResult = await supabase.auth.signUp({
          email,
          password,
          options: {
            data: { role },
            emailRedirectTo: `${window.location.origin}/auth/callback`,
          }
        })
        if (!authResult.error) {
          setMessage("登録に成功しました！ログインしてください。")
        }
      } else {
        authResult = await supabase.auth.signInWithPassword({
          email,
          password
        })
        if (!authResult.error) {
          setMessage("ログインに成功しました！")
        }
      }

      const { data, error } = authResult

      if (error) throw error

      console.log('認証成功、ユーザーデータ:', data) // デバッグログ
    } catch (error: any) {
      setMessage(error.message)
    } finally {
      setLoading(false)
    }
  }

  const handleLogout = async () => {
    const supabase = createClient()
    await supabase.auth.signOut()
    setMessage("ログアウトしました。")
  }

  if (user) {
    console.log('現在のユーザー:', user) // デバッグログ
    return (
      <div className="space-y-4">
        <p className="text-sm text-gray-600">ログイン中: {user.email}</p>
        <Badge>{user.role}</Badge>
        <Button onClick={handleLogout}>ログアウト</Button>
        {message && (
          <Alert>
            <AlertDescription>{message}</AlertDescription>
          </Alert>
        )}
      </div>
    )
  }

  return (
    <form onSubmit={handleAuth} className="space-y-6 max-w-md mx-auto">
      {message && (
        <Alert variant={message.includes("無効な管理者シークレット") ? "destructive" : "default"}>
          <AlertDescription>{message}</AlertDescription>
        </Alert>
      )}
      <div className="space-y-2">
        <Label htmlFor="email">メールアドレス</Label>
        <Input
          id="email"
          type="email"
          placeholder="メールアドレスを入力"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          required
        />
      </div>
      <div className="space-y-2">
        <Label htmlFor="password">パスワード</Label>
        <Input
          id="password"
          type="password"
          placeholder="パスワードを入力"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          required
        />
      </div>
      {isRegistering && (
        <div className="space-y-2">
          <Label htmlFor="role">役割</Label>
          <Select value={role} onValueChange={(value) => setRole(value as Role)}>
            <SelectTrigger>
              <SelectValue placeholder="役割を選択" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value={Role.EMPLOYEE}>{translateRole(Role.EMPLOYEE)}</SelectItem>
              <SelectItem value={Role.MANAGER}>{translateRole(Role.MANAGER)}</SelectItem>
              <SelectItem value={Role.ADMIN}>{translateRole(Role.ADMIN)}</SelectItem>
            </SelectContent>
          </Select>
        </div>
      )}
      {isRegistering && role === Role.ADMIN && (
        <div className="space-y-2">
          <Label htmlFor="adminSecret">管理者シークレット</Label>
          <Input
            id="adminSecret"
            type="password"
            placeholder="管理者シークレットを入力"
            value={adminSecret}
            onChange={(e) => setAdminSecret(e.target.value)}
            required
          />
        </div>
      )}
      <div className="flex flex-col space-y-4">
        <Button type="submit" disabled={loading} className="w-full">
          {loading ? '処理中...' : (isRegistering ? '登録' : 'ログイン')}
        </Button>
        <Button type="button" variant="outline" onClick={() => {
          setIsRegistering(!isRegistering)
          setMessage(null)
          setAdminSecret('')
        }} className="w-full">
          {isRegistering ? 'ログインに切り替え' : '登録に切り替え'}
        </Button>
      </div>
    </form>
  )
}

//////////////// FILE: components/AuthProvider.tsx ////////////////

// components/AuthProvider.tsx

"use client"

import { createContext, useContext, useEffect, useState } from 'react'
import { User } from '@supabase/supabase-js'
import { createClient } from '@/lib/supabase/client'
import { Role } from '@prisma/client'

type AuthContextType = {
  user: (User & { role: Role; department?: string | null }) | null
  loading: boolean
  updateUserInfo: (updatedUser: User & { role: Role; department?: string | null }) => void
}

const AuthContext = createContext<AuthContextType>({ user: null, loading: true, updateUserInfo: () => {} })

export const useAuth = () => useContext(AuthContext)

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<(User & { role: Role; department?: string | null }) | null>(null)
  const [loading, setLoading] = useState(true)
  const supabase = createClient()

  useEffect(() => {
    const { data: { subscription } } = supabase.auth.onAuthStateChange(
      async (event, session) => {
        if (session?.user) {
          const { id, email, user_metadata } = session.user
          const role = (user_metadata?.role as Role) || Role.EMPLOYEE
          const currentUser = { ...session.user, role }
          setUser(currentUser)
          setLoading(false)

          // 初回ログイン時のみ Prisma User テーブルと同期
          try {
            const response = await fetch('/api/auth/sync-user', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                id,
                email,
              }),
            })
            if (response.ok) {
              const syncedUser = await response.json()
              setUser(prevUser => ({ ...prevUser, ...syncedUser.user }))
            } else {
              console.error('ユーザーの同期に失敗しました')
            }
          } catch (error: any) {
            console.error('ユーザーの同期中にエラーが発生しました:', error)
          }
        } else {
          setUser(null)
          setLoading(false)
        }
      }
    )

    return () => {
      subscription.unsubscribe()
    }
  }, [])

  const updateUserInfo = (updatedUser: User & { role: Role; department?: string | null }) => {
    setUser(updatedUser)
  }

  return (
    <AuthContext.Provider value={{ user, loading, updateUserInfo }}>
      {children}
    </AuthContext.Provider>
  )
}

//////////////// FILE: components/CsvUploader.tsx ////////////////

// components/CSVUploader.tsx

import { useState } from 'react'
import { Button } from '@/components/ui/button'
import { FileInput } from '@/components/custom/FileInput'
import { Role } from '@prisma/client'

type OrganizationUser = {
  organization: string;
  managerEmail: string;
  role: Role;
  email: string;
}

type CSVUploaderProps = {
  onUploadSuccess: (data: OrganizationUser[]) => void;
}

export default function CSVUploader({ onUploadSuccess }: CSVUploaderProps) {
  const [file, setFile] = useState<File | null>(null)

  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    if (event.target.files) {
      setFile(event.target.files[0])
    }
  }

  const handleUpload = async () => {
    if (!file) {
      console.error('ファイルが選択されていません')
      return
    }

    const formData = new FormData()
    formData.append('file', file)

    try {
      const response = await fetch('/api/organization/upload', {
        method: 'POST',
        body: formData,
      })

      const result = await response.json()

      if (response.ok) {
        onUploadSuccess(result.data)
      } else {
        throw new Error(result.message || 'アップロードに失敗しました')
      }
    } catch (error: any) {
      console.error('アップロード中にエラーが発生しました:', error)
    }
  }

  const handleDownloadCSV = async () => {
    try {
      const response = await fetch('/api/organization/download')
      if (response.ok) {
        const blob = await response.blob()
        const url = window.URL.createObjectURL(blob)
        const a = document.createElement('a')
        a.style.display = 'none'
        a.href = url
        a.download = 'organization_structure.csv'
        document.body.appendChild(a)
        a.click()
        window.URL.revokeObjectURL(url)
      } else {
        console.error('CSVのダウンロードに失敗しました')
      }
    } catch (error: any) {
      console.error('CSVのダウンロード中にエラーが発生しました:', error)
    }
  }

  return (
    <div className="space-y-4">
      <div className="flex justify-between items-center">
        <FileInput onChange={handleFileChange} accept=".csv" />
        <Button onClick={handleDownloadCSV} variant="outline">
          現在の組織構造をCSVダウンロード
        </Button>
      </div>
      <Button onClick={handleUpload}>アップロード</Button>
    </div>
  )
}

//////////////// FILE: components/DataPreview.tsx ////////////////

// components/DataPreview.tsx

import { Button } from '@/components/ui/button'
import {
  Table,
  TableBody,
  TableCaption,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table"
import { Role } from '@prisma/client'

type OrganizationUser = {
  organization: string;
  managerEmail: string;
  role: Role;
  email: string;
}

type DataPreviewProps = {
  data: OrganizationUser[];
  onConfirm: () => void;
  onCancel: () => void;
}

export default function DataPreview({ data, onConfirm, onCancel }: DataPreviewProps) {
  return (
    <div className="mt-8">
      <h3 className="text-lg font-semibold mb-4">アップロードされたデータのプレビュー</h3>
      <Table>
        <TableCaption>アップロードされたデータのプレビュー</TableCaption>
        <TableHeader>
          <TableRow>
            <TableHead>組織</TableHead>
            <TableHead>上司</TableHead>
            <TableHead>役職（ロール）</TableHead>
            <TableHead>メールアドレス</TableHead>
          </TableRow>
        </TableHeader>
        <TableBody>
          {data.map((user, index) => (
            <TableRow key={index}>
              <TableCell>{user.organization}</TableCell>
              <TableCell>{user.managerEmail}</TableCell>
              <TableCell>{user.role}</TableCell>
              <TableCell>{user.email}</TableCell>
            </TableRow>
          ))}
        </TableBody>
      </Table>
      <div className="mt-4 space-x-2">
        <Button onClick={onConfirm}>確認して登録</Button>
        <Button variant="outline" onClick={onCancel}>キャンセル</Button>
      </div>
    </div>
  )
}

//////////////// FILE: components/GoalDetails.tsx ////////////////

// components/GoalDetails.tsx

import React, { useState } from 'react'
import { Goal, GoalStatus, Feedback, User } from '@prisma/client'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { Badge } from '@/components/ui/badge'
import { Button } from '@/components/ui/button'
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert"
import { translateGoalStatus } from '@/lib/translations'
import GoalEditForm from './GoalEditForm'

type GoalWithFeedbacksAndUsers = Goal & { 
  feedbacks: (Feedback & { user: User })[]
}

type GoalDetailsProps = {
  goal: GoalWithFeedbacksAndUsers
  onUpdate: (updatedGoal: GoalWithFeedbacksAndUsers) => void
  onDelete: (goalId: string) => void
}

export default function GoalDetails({ goal, onUpdate, onDelete }: GoalDetailsProps) {
  const [editingGoalId, setEditingGoalId] = useState<string | null>(null)
  const [error, setError] = useState<string | null>(null)

  // 改行を保持してテキストを表示するヘルパー関数
  const renderWithLineBreaks = (text: string) => {
    return text.split('\n').map((line, index) => (
      <React.Fragment key={index}>
        {line}
        <br />
      </React.Fragment>
    ));
  };

  // 目標の各セクションを表示するコンポーネント
  const GoalSection = ({ title, content }: { title: string; content: string }) => (
    <div className="mb-4">
      <h4 className="text-sm font-semibold text-gray-600 mb-1">{title}</h4>
      <div className="bg-gray-50 p-3 rounded-md border border-gray-200">
        <p className="text-sm text-gray-800">{renderWithLineBreaks(content)}</p>
      </div>
    </div>
  );

  const handleEdit = (goalId: string) => {
    setEditingGoalId(goalId)
  }

  const handleSave = async (updatedGoal: Goal) => {
    try {
      const response = await fetch(`/api/goals`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(updatedGoal),
      })

      if (!response.ok) {
        throw new Error('目標の更新に失敗しました')
      }

      const savedGoal = await response.json()
      onUpdate(savedGoal)
      setEditingGoalId(null)
      setError(null)
    } catch (error: any) {
      console.error('Error updating goal:', error)
      setError('目標の更新中にエラーが発生しました')
    }
  }

  const handleSubmitForReview = async (goalId: string) => {
    try {
      const response = await fetch(`/api/goals`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ id: goalId, status: GoalStatus.SUBMITTED }),
      })

      if (!response.ok) {
        throw new Error('目標のレビュー申請に失敗しました')
      }

      const updatedGoal = await response.json()
      onUpdate(updatedGoal)
      setError(null)
    } catch (error: any) {
      console.error('Error submitting goal for review:', error)
      setError('目標のレビュー申請中にエラーが発生しました')
    }
  }

  const handleResubmit = async (goalId: string) => {
    try {
      const response = await fetch(`/api/goals`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ id: goalId, status: GoalStatus.SUBMITTED }),
      })

      if (!response.ok) {
        throw new Error('目標の再提出に失敗しました')
      }

      const updatedGoal = await response.json()
      onUpdate(updatedGoal)
      setError(null)
    } catch (error: any) {
      console.error('Error resubmitting goal:', error)
      setError('目標の再提出中にエラーが発生しました')
    }
  }

  return (
    <Card key={goal.id} className="mb-4">
      <CardHeader>
        <CardTitle>目標詳細</CardTitle>
      </CardHeader>
      <CardContent>
        {error && (
          <Alert variant="destructive" className="mb-4">
            <AlertDescription>{error}</AlertDescription>
          </Alert>
        )}
        {editingGoalId === goal.id ? (
          <GoalEditForm
            goal={goal}
            onSave={handleSave}
            onCancel={() => setEditingGoalId(null)}
          />
        ) : (
          <>
            <h3 className="font-semibold text-lg mt-4 mb-3">1. 組織目標</h3>
            <GoalSection title="組織目標" content={goal.organizationGoal} />
            
            <h3 className="font-semibold text-lg mt-6 mb-3">2. パフォーマンス目標</h3>
            <GoalSection title="担う役割" content={goal.performanceRole} />
            <GoalSection title="達成基準" content={goal.performanceCriteria} />
            
            <h3 className="font-semibold text-lg mt-6 mb-3">3. ストレッチ目標</h3>
            <GoalSection title="目指す姿" content={goal.stretchVision} />
            <GoalSection title="目指す姿とのギャップ" content={goal.stretchGap} />
            <GoalSection title="アクションプラン" content={goal.stretchAction} />
            <GoalSection title="達成基準" content={goal.stretchCriteria} />
            
            <Badge className="mt-4">{translateGoalStatus(goal.status)}</Badge>
            <div className="space-y-4 mt-4">
              {goal.feedbacks && goal.feedbacks.length > 0 ? (
                goal.feedbacks
                  .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime())
                  .map((feedback, index) => (
                    <Alert key={feedback.id} className="mb-2">
                      <AlertTitle className="text-sm font-semibold mb-2">
                        フィードバック {goal.feedbacks.length - index}:
                      </AlertTitle>
                      <AlertDescription>
                        <div className="text-sm whitespace-pre-wrap mb-2">
                          {feedback.content}
                        </div>
                        <div className="text-xs text-gray-500">
                          レビュアー: {feedback.user.name ? `${feedback.user.name} (${feedback.user.email})` : feedback.user.email}
                          <br />
                          ステータス: {translateGoalStatus(feedback.status)} | 日時: {new Date(feedback.createdAt).toLocaleString()}
                        </div>
                      </AlertDescription>
                    </Alert>
                  ))
              ) : (
                <p className="text-sm text-gray-500">フィードバックはまだありません。</p>
              )}
            </div>
            <div className="flex space-x-2 mt-4">
              {(goal.status === GoalStatus.DRAFT || 
                goal.status === GoalStatus.REJECTED || 
                goal.status === GoalStatus.APPROVED) && (
                <Button onClick={() => handleEdit(goal.id)}>編集</Button>
              )}
              {goal.status === GoalStatus.DRAFT && (
                <Button onClick={() => handleSubmitForReview(goal.id)}>レビュー申請</Button>
              )}
              {(goal.status === GoalStatus.REJECTED || 
                goal.status === GoalStatus.APPROVED) && (
                <Button onClick={() => handleResubmit(goal.id)}>再提出</Button>
              )}
              <Button variant="destructive" onClick={() => onDelete(goal.id)}>削除</Button>
            </div>
          </>
        )}
      </CardContent>
    </Card>
  )
}

//////////////// FILE: components/GoalEditForm.tsx ////////////////

// components/GoalEditForm.tsx

import React, { useState } from 'react'
import { Goal, GoalStatus } from '@prisma/client'
import { Button } from '@/components/ui/button'
import { Textarea } from '@/components/ui/textarea'

interface GoalEditFormProps {
  goal: Goal
  onSave: (updatedGoal: Goal) => void
  onCancel: () => void
}

export default function GoalEditForm({ goal, onSave, onCancel }: GoalEditFormProps) {
  const [organizationGoal, setOrganizationGoal] = useState(goal.organizationGoal)
  const [performanceRole, setPerformanceRole] = useState(goal.performanceRole)
  const [performanceCriteria, setPerformanceCriteria] = useState(goal.performanceCriteria)
  const [stretchVision, setStretchVision] = useState(goal.stretchVision)
  const [stretchGap, setStretchGap] = useState(goal.stretchGap)
  const [stretchAction, setStretchAction] = useState(goal.stretchAction)
  const [stretchCriteria, setStretchCriteria] = useState(goal.stretchCriteria)
  const [isSubmitting, setIsSubmitting] = useState(false)

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    setIsSubmitting(true)
    try {
      await onSave({
        ...goal,
        organizationGoal,
        performanceRole,
        performanceCriteria,
        stretchVision,
        stretchGap,
        stretchAction,
        stretchCriteria,
        status: GoalStatus.DRAFT
      })
    } catch (error: any) {
      console.error('目標の保存中にエラーが発生しました:', error)
    } finally {
      setIsSubmitting(false)
    }
  }

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <Textarea
        value={organizationGoal}
        onChange={(e) => setOrganizationGoal(e.target.value)}
        placeholder="1. 組織目標"
        required
      />
      <Textarea
        value={performanceRole}
        onChange={(e) => setPerformanceRole(e.target.value)}
        placeholder="2-1. パフォーマンス目標 - 担う役割"
        required
      />
      <Textarea
        value={performanceCriteria}
        onChange={(e) => setPerformanceCriteria(e.target.value)}
        placeholder="2-2. パフォーマンス目標 - 達成基準"
        required
      />
      <Textarea
        value={stretchVision}
        onChange={(e) => setStretchVision(e.target.value)}
        placeholder="3-1. ストレッチ目標 - 目指す姿"
        required
      />
      <Textarea
        value={stretchGap}
        onChange={(e) => setStretchGap(e.target.value)}
        placeholder="3-2. ストレッチ目標 - 目指す姿とのギャップ"
        required
      />
      <Textarea
        value={stretchAction}
        onChange={(e) => setStretchAction(e.target.value)}
        placeholder="3-3. ストレッチ目標 - アクションプラン"
        required
      />
      <Textarea
        value={stretchCriteria}
        onChange={(e) => setStretchCriteria(e.target.value)}
        placeholder="3-4. ストレッチ目標 - 達成基準"
        required
      />
      <div className="flex space-x-2">
        <Button type="submit" disabled={isSubmitting}>
          {isSubmitting ? '保存中...' : '変更を保存'}
        </Button>
        <Button type="button" variant="outline" onClick={onCancel}>キャンセル</Button>
      </div>
    </form>
  )
}

//////////////// FILE: components/GoalForm.tsx ////////////////

// components/GoalForm.tsx

import React, { useState } from 'react'
import { useAuth } from './AuthProvider'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Textarea } from '@/components/ui/textarea'
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import { GoalStatus } from '@prisma/client'
import { Alert, AlertDescription } from "@/components/ui/alert"

export default function GoalForm({ onGoalAdded }: { onGoalAdded: () => void }) {
  const [organizationGoal, setOrganizationGoal] = useState('')
  const [performanceRole, setPerformanceRole] = useState('')
  const [performanceCriteria, setPerformanceCriteria] = useState('')
  const [stretchVision, setStretchVision] = useState('')
  const [stretchGap, setStretchGap] = useState('')
  const [stretchAction, setStretchAction] = useState('')
  const [stretchCriteria, setStretchCriteria] = useState('')
  const [status, setStatus] = useState<GoalStatus>(GoalStatus.DRAFT)
  const [quarter, setQuarter] = useState<number>(1)
  const [year, setYear] = useState<number>(new Date().getFullYear())
  const [error, setError] = useState<string | null>(null)
  const { user } = useAuth()

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    if (!user) return

    try {
      const response = await fetch('/api/goals', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          organizationGoal,
          performanceRole,
          performanceCriteria,
          stretchVision,
          stretchGap,
          stretchAction,
          stretchCriteria,
          status,
          userId: user.id,
          quarter,
          year
        }),
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.message || '目標の追加に失敗しました')
      }

      setOrganizationGoal('')
      setPerformanceRole('')
      setPerformanceCriteria('')
      setStretchVision('')
      setStretchGap('')
      setStretchAction('')
      setStretchCriteria('')
      setStatus(GoalStatus.DRAFT)
      setError(null)
      onGoalAdded()
    } catch (error: any) {
      setError(error.message)
    }
  }

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      {error && (
        <Alert variant="destructive">
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}
      <Textarea
        value={organizationGoal}
        onChange={(e) => setOrganizationGoal(e.target.value)}
        placeholder="1. 組織目標"
        required
      />
      <Textarea
        value={performanceRole}
        onChange={(e) => setPerformanceRole(e.target.value)}
        placeholder="2-1. パフォーマンス目標 - 担う役割"
        required
      />
      <Textarea
        value={performanceCriteria}
        onChange={(e) => setPerformanceCriteria(e.target.value)}
        placeholder="2-2. パフォーマンス目標 - 達成基準"
        required
      />
      <Textarea
        value={stretchVision}
        onChange={(e) => setStretchVision(e.target.value)}
        placeholder="3-1. ストレッチ目標 - 目指す姿"
        required
      />
      <Textarea
        value={stretchGap}
        onChange={(e) => setStretchGap(e.target.value)}
        placeholder="3-2. ストレッチ目標 - 目指す姿とのギャップ"
        required
      />
      <Textarea
        value={stretchAction}
        onChange={(e) => setStretchAction(e.target.value)}
        placeholder="3-3. ストレッチ目標 - アクションプラン"
        required
      />
      <Textarea
        value={stretchCriteria}
        onChange={(e) => setStretchCriteria(e.target.value)}
        placeholder="3-4. ストレッチ目標 - 達成基準"
        required
      />
      <Select value={status} onValueChange={(value) => setStatus(value as GoalStatus)}>
        <SelectTrigger>
          <SelectValue placeholder="ステータスを選択" />
        </SelectTrigger>
        <SelectContent>
          <SelectItem value={GoalStatus.DRAFT}>下書き</SelectItem>
          <SelectItem value={GoalStatus.SUBMITTED}>レビュー申請</SelectItem>
        </SelectContent>
      </Select>
      <Select value={quarter.toString()} onValueChange={(value) => setQuarter(parseInt(value))}>
        <SelectTrigger>
          <SelectValue placeholder="四半期を選択" />
        </SelectTrigger>
        <SelectContent>
          <SelectItem value="1">第1四半期</SelectItem>
          <SelectItem value="2">第2四半期</SelectItem>
          <SelectItem value="3">第3四半期</SelectItem>
          <SelectItem value="4">第4四半期</SelectItem>
        </SelectContent>
      </Select>
      <Input
        type="number"
        value={year}
        onChange={(e) => setYear(parseInt(e.target.value))}
        placeholder="年"
        min={2000}
        max={2100}
        required
      />
      <Button type="submit">目標を追加</Button>
    </form>
  )
}

//////////////// FILE: components/GoalList.tsx ////////////////

// components/GoalList.tsx

import React, { useState, useEffect } from 'react'
import { Goal, GoalStatus, Feedback, User } from '@prisma/client'
import { useAuth } from './AuthProvider'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { Alert, AlertDescription } from "@/components/ui/alert"
import GoalListHeader from './GoalListHeader'
import NewGoalForm from './NewGoalForm'
import GoalDetails from './GoalDetails'

type GoalWithFeedbacksAndUsers = Goal & { 
  feedbacks: (Feedback & { user: User })[]
}

export default function GoalList() {
  const [goals, setGoals] = useState<GoalWithFeedbacksAndUsers[]>([])
  const [selectedYear, setSelectedYear] = useState<number | null>(null)
  const [selectedQuarter, setSelectedQuarter] = useState<number | null>(null)
  const [error, setError] = useState<string | null>(null)
  const { user, loading } = useAuth()

  const fetchGoals = async (userId: string) => {
    const response = await fetch(`/api/goals?userId=${userId}`)
    const data = await response.json()
    setGoals(data)

    if (data.length > 0) {
      const latestGoal = data.reduce((latest: GoalWithFeedbacksAndUsers, current: GoalWithFeedbacksAndUsers) => 
        latest.year > current.year || (latest.year === current.year && latest.quarter > current.quarter) 
          ? latest 
          : current
      )
      setSelectedYear(latestGoal.year)
      setSelectedQuarter(latestGoal.quarter)
    } else {
      const now = new Date()
      setSelectedYear(now.getFullYear())
      setSelectedQuarter(Math.floor(now.getMonth() / 3) + 1)
    }
  }

  useEffect(() => {
    if (user) {
      fetchGoals(user.id)
    }
  }, [user])

  const handleGoalUpdate = (updatedGoal: GoalWithFeedbacksAndUsers) => {
    setGoals(goals.map(g => g.id === updatedGoal.id ? updatedGoal : g))
  }

  const handleGoalDelete = async (goalId: string) => {
    const response = await fetch(`/api/goals?id=${goalId}`, {
      method: 'DELETE',
    })

    if (response.ok) {
      fetchGoals(user!.id)
    } else {
      console.error('目標の削除に失敗しました')
    }
  }

  if (loading) {
    return <p>読み込み中...</p>
  }

  if (!user) {
    return null
  }

  const currentGoal = goals.find(goal => 
    goal.year === selectedYear && goal.quarter === selectedQuarter
  )

  const canCreateNewGoal = !currentGoal

  return (
    <div className="space-y-6">
      <Card>
        <CardHeader>
          <CardTitle>目標管理</CardTitle>
        </CardHeader>
        <CardContent>
          <GoalListHeader
            goals={goals}
            selectedYear={selectedYear}
            selectedQuarter={selectedQuarter}
            setSelectedYear={setSelectedYear}
            setSelectedQuarter={setSelectedQuarter}
          />
          
          {error && (
            <Alert variant="destructive" className="mb-4">
              <AlertDescription>{error}</AlertDescription>
            </Alert>
          )}

          {canCreateNewGoal ? (
            <NewGoalForm
              userId={user.id}
              selectedYear={selectedYear!}
              selectedQuarter={selectedQuarter!}
              onGoalCreated={() => fetchGoals(user.id)}
              setError={setError}
            />
          ) : (
            <Alert className="mb-4">
              <AlertDescription>この期間の目標は既に設定されています。編集または削除して変更してください。</AlertDescription>
            </Alert>
          )}

          {currentGoal && (
            <GoalDetails
              goal={currentGoal}
              onUpdate={handleGoalUpdate}
              onDelete={handleGoalDelete}
            />
          )}
        </CardContent>
      </Card>
    </div>
  )
}

//////////////// FILE: components/GoalListHeader.tsx ////////////////

// components/GoalListHeader.tsx

import React from 'react'
import { Goal } from '@prisma/client'
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"

type GoalListHeaderProps = {
  goals: Goal[]
  selectedYear: number | null
  selectedQuarter: number | null
  setSelectedYear: (year: number) => void
  setSelectedQuarter: (quarter: number) => void
}

export default function GoalListHeader({
  goals,
  selectedYear,
  selectedQuarter,
  setSelectedYear,
  setSelectedQuarter
}: GoalListHeaderProps) {
  const availableYears = Array.from(new Set(goals.map(g => g.year))).sort((a, b) => b - a)
  const availableQuarters = [1, 2, 3, 4]

  return (
    <div className="flex space-x-4 mb-4">
      <Select 
        value={selectedYear?.toString() || ''} 
        onValueChange={(value) => setSelectedYear(parseInt(value))}
      >
        <SelectTrigger>
          <SelectValue placeholder="年を選択" />
        </SelectTrigger>
        <SelectContent>
          {availableYears.map(year => (
            <SelectItem key={year} value={year.toString()}>{year}年</SelectItem>
          ))}
          <SelectItem value={(new Date().getFullYear() + 1).toString()}>
            {new Date().getFullYear() + 1}年
          </SelectItem>
        </SelectContent>
      </Select>
      <Select 
        value={selectedQuarter?.toString() || ''} 
        onValueChange={(value) => setSelectedQuarter(parseInt(value))}
      >
        <SelectTrigger>
          <SelectValue placeholder="四半期を選択" />
        </SelectTrigger>
        <SelectContent>
          {availableQuarters.map(quarter => (
            <SelectItem key={quarter} value={quarter.toString()}>第{quarter}四半期</SelectItem>
          ))}
        </SelectContent>
      </Select>
    </div>
  )
}

//////////////// FILE: components/GoalReviewList.tsx ////////////////

// components/GoalReviewList.tsx

"use client"

import React, { useState, useEffect } from 'react'
import { useAuth } from './AuthProvider'
import { Goal, GoalStatus, Role, User, Feedback } from '@prisma/client'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { Badge } from '@/components/ui/badge'
import { Button } from '@/components/ui/button'
import { Textarea } from '@/components/ui/textarea'
import { Alert, AlertDescription } from "@/components/ui/alert"
import { translateGoalStatus } from '@/lib/translations'

type GoalWithUserAndFeedbacks = Goal & { 
  user?: User,
  feedbacks: Feedback[]
}

export default function GoalReviewList() {
  const [goals, setGoals] = useState<GoalWithUserAndFeedbacks[]>([])
  const [feedback, setFeedback] = useState<{ [key: string]: string }>({})
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const { user } = useAuth()

  useEffect(() => {
    if (user && user.role === Role.MANAGER) {
      fetchGoalsForReview()
    }
  }, [user])

  const fetchGoalsForReview = async () => {
    setLoading(true)
    setError(null)
    try {
      const response = await fetch(`/api/goals?managerId=${user?.id}&status=SUBMITTED`)
      if (!response.ok) {
        throw new Error('目標の取得に失敗しました')
      }
      const data = await response.json()
      console.log('取得した目標:', data)
      setGoals(data)
    } catch (err) {
      console.error('目標の取得中にエラーが発生しました:', err)
      setError('レビュー対象の目標を読み込めませんでした。後でもう一度お試しください。')
    } finally {
      setLoading(false)
    }
  }

  const handleApprove = async (goalId: string) => {
    await updateGoalStatus(goalId, GoalStatus.APPROVED)
  }

  const handleReject = async (goalId: string) => {
    await updateGoalStatus(goalId, GoalStatus.REJECTED)
  }

  const updateGoalStatus = async (goalId: string, status: GoalStatus) => {
    try {
      const response = await fetch('/api/goals/approve', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          goalId,
          managerId: user?.id,
          status,
          feedback: feedback[goalId] || '',
        }),
      })

      if (!response.ok) {
        throw new Error('目標のステータス更新に失敗しました')
      }

      const updatedGoal = await response.json()
      setGoals(goals.map(g => g.id === updatedGoal.id ? updatedGoal : g))
      setFeedback({...feedback, [goalId]: ''})
      fetchGoalsForReview()  // 目標リストを更新
    } catch (err) {
      console.error('目標のステータス更新中にエラーが発生しました:', err)
      setError('目標のステータス更新に失敗しました。もう一度お試しください。')
    }
  }

  if (user?.role !== Role.MANAGER) {
    return null
  }

  if (loading) {
    return <div>レビュー対象の目標を読み込み中...</div>
  }

  if (error) {
    return <Alert variant="destructive"><AlertDescription>{error}</AlertDescription></Alert>
  }

  return (
    <div className="space-y-4">
      <h2 className="text-2xl font-bold">レビュー対象の目標</h2>
      {goals.length === 0 ? (
        <Alert>
          <AlertDescription>現在レビュー対象の目標はありません。これは以下の理由が考えられます：
            <ul className="list-disc list-inside mt-2">
              <li>あなたに割り当てられた従業員がいない</li>
              <li>従業員がまだ目標をレビュー申請していない</li>
              <li>すべての申請済み目標がすでにレビュー済みである</li>
            </ul>
          </AlertDescription>
        </Alert>
      ) : (
        goals.map((goal) => (
          <Card key={goal.id}>
            <CardHeader>
              <CardTitle>
                {goal.user
                  ? (goal.user.name
                      ? `${goal.user.name} (${goal.user.email})`
                      : goal.user.email)
                  : '不明な従業員'} の目標
              </CardTitle>
            </CardHeader>
            <CardContent>
              <h3 className="font-semibold mt-2">1. 組織目標</h3>
              <p className="text-sm text-gray-600 mb-2">{goal.organizationGoal}</p>
              
              <h3 className="font-semibold mt-4">2. パフォーマンス目標</h3>
              <h4 className="font-medium mt-2">担う役割</h4>
              <p className="text-sm text-gray-600 mb-2">{goal.performanceRole}</p>
              <h4 className="font-medium mt-2">達成基準</h4>
              <p className="text-sm text-gray-600 mb-2">{goal.performanceCriteria}</p>
              
              <h3 className="font-semibold mt-4">3. ストレッチ目標</h3>
              <h4 className="font-medium mt-2">目指す姿</h4>
              <p className="text-sm text-gray-600 mb-2">{goal.stretchVision}</p>
              <h4 className="font-medium mt-2">目指す姿とのギャップ</h4>
              <p className="text-sm text-gray-600 mb-2">{goal.stretchGap}</p>
              <h4 className="font-medium mt-2">アクションプラン</h4>
              <p className="text-sm text-gray-600 mb-2">{goal.stretchAction}</p>
              <h4 className="font-medium mt-2">達成基準</h4>
              <p className="text-sm text-gray-600 mb-2">{goal.stretchCriteria}</p>
              
              <Badge className="mt-4">{translateGoalStatus(goal.status)}</Badge>
              {goal.feedbacks && goal.feedbacks.length > 0 && (
                <div className="mt-2">
                  <h3 className="font-semibold">フィードバック履歴:</h3>
                  {goal.feedbacks.map((fb, index) => (
                    <Alert key={fb.id} className="mt-1">
                      <AlertDescription>
                        <strong>フィードバック {goal.feedbacks.length - index}:</strong> {fb.content}
                        <br />
                        <span className="text-xs text-gray-500">
                          ステータス: {translateGoalStatus(fb.status)} | 日時: {new Date(fb.createdAt).toLocaleString()}
                        </span>
                      </AlertDescription>
                    </Alert>
                  ))}
                </div>
              )}
              <Textarea
                className="mt-4"
                placeholder="フィードバックを入力してください"
                value={feedback[goal.id] || ''}
                onChange={(e) => setFeedback({ ...feedback, [goal.id]: e.target.value })}
              />
              <div className="flex space-x-2 mt-4">
                <Button onClick={() => handleApprove(goal.id)}>承認</Button>
                <Button variant="destructive" onClick={() => handleReject(goal.id)}>却下</Button>
              </div>
            </CardContent>
          </Card>
        ))
      )}
    </div>
  )
}

//////////////// FILE: components/Header.tsx ////////////////

// components/Header.tsx

'use client'

import Link from 'next/link'
import { useAuth } from './AuthProvider'
import { Button } from '@/components/ui/button'
import { createClient } from '@/lib/supabase/client'

export function Header() {
  const { user, loading }: any = useAuth()
  const supabase = createClient()

  return (
    <header className="bg-white shadow-sm">
      <div className="container mx-auto px-4 py-4 flex items-center justify-between">
        <Link href="/" className="text-2xl font-bold text-gray-800">
          目標設定アプリ
        </Link>
        <nav>
          {!loading && user && (
            <div className="flex items-center space-x-4">
              <span className="text-sm text-gray-600">
                {user.name ? `${user.name} (${user.email})` : user.email}
              </span>
              <Button variant="outline" onClick={async () => {
                await supabase.auth.signOut()
              }}>
                ログアウト
              </Button>
            </div>
          )}
        </nav>
      </div>
    </header>
  )
}

//////////////// FILE: components/NewGoalForm.tsx ////////////////

// components/NewGoalForm.tsx

import React, { useState } from 'react'
import { GoalStatus } from '@prisma/client'
import { Button } from '@/components/ui/button'
import { Textarea } from '@/components/ui/textarea'

type NewGoalFormProps = {
  userId: string
  selectedYear: number
  selectedQuarter: number
  onGoalCreated: () => void
  setError: (error: string | null) => void
}

export default function NewGoalForm({
  userId,
  selectedYear,
  selectedQuarter,
  onGoalCreated,
  setError
}: NewGoalFormProps) {
  const [organizationGoal, setOrganizationGoal] = useState('')
  const [performanceRole, setPerformanceRole] = useState('')
  const [performanceCriteria, setPerformanceCriteria] = useState('')
  const [stretchVision, setStretchVision] = useState('')
  const [stretchGap, setStretchGap] = useState('')
  const [stretchAction, setStretchAction] = useState('')
  const [stretchCriteria, setStretchCriteria] = useState('')

  const handleCreateGoal = async () => {
    try {
      const response = await fetch('/api/goals', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          organizationGoal,
          performanceRole,
          performanceCriteria,
          stretchVision,
          stretchGap,
          stretchAction,
          stretchCriteria,
          status: GoalStatus.DRAFT,
          userId,
          year: selectedYear,
          quarter: selectedQuarter
        }),
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.message || '目標の作成に失敗しました')
      }

      setOrganizationGoal('')
      setPerformanceRole('')
      setPerformanceCriteria('')
      setStretchVision('')
      setStretchGap('')
      setStretchAction('')
      setStretchCriteria('')
      setError(null)
      onGoalCreated()
    } catch (error: any) {
      setError(error.message)
    }
  }

  return (
    <div className="space-y-4 mb-6">
      <Textarea
        placeholder="1. 組織目標"
        value={organizationGoal}
        onChange={(e) => setOrganizationGoal(e.target.value)}
      />
      <Textarea
        placeholder="2-1. パフォーマンス目標 - 担う役割"
        value={performanceRole}
        onChange={(e) => setPerformanceRole(e.target.value)}
      />
      <Textarea
        placeholder="2-2. パフォーマンス目標 - 達成基準"
        value={performanceCriteria}
        onChange={(e) => setPerformanceCriteria(e.target.value)}
      />
      <Textarea
        placeholder="3-1. ストレッチ目標 - 目指す姿"
        value={stretchVision}
        onChange={(e) => setStretchVision(e.target.value)}
      />
      <Textarea
        placeholder="3-2. ストレッチ目標 - 目指す姿とのギャップ"
        value={stretchGap}
        onChange={(e) => setStretchGap(e.target.value)}
      />
      <Textarea
        placeholder="3-3. ストレッチ目標 - アクションプラン"
        value={stretchAction}
        onChange={(e) => setStretchAction(e.target.value)}
      />
      <Textarea
        placeholder="3-4. ストレッチ目標 - 達成基準"
        value={stretchCriteria}
        onChange={(e) => setStretchCriteria(e.target.value)}
      />
      <Button onClick={handleCreateGoal}>新しい目標を作成</Button>
    </div>
  )
}

//////////////// FILE: components/OrganizationChart.tsx ////////////////

// components/OrganizationChart.tsx

import React, { useCallback, useMemo } from 'react';
import ReactFlow, {
  Node,
  Edge,
  useNodesState,
  useEdgesState,
  addEdge,
  Connection,
  ConnectionLineType,
  MarkerType,
} from 'reactflow';
import dagre from 'dagre';
import 'reactflow/dist/style.css';

type User = {
  id: string;
  name: string;
  email: string;
  role: string;
};

type Department = {
  name: string;
  users: User[];
  children: Department[];
};

type OrganizationChartProps = {
  data: Department;
};

const nodeWidth = 250;
const nodeHeight = 120;

const getLayoutedElements = (nodes: Node[], edges: Edge[], direction = 'TB') => {
  const dagreGraph = new dagre.graphlib.Graph();
  dagreGraph.setDefaultEdgeLabel(() => ({}));

  const isHorizontal = direction === 'LR';
  dagreGraph.setGraph({ rankdir: direction });

  nodes.forEach((node) => {
    dagreGraph.setNode(node.id, { width: nodeWidth, height: nodeHeight });
  });

  edges.forEach((edge) => {
    dagreGraph.setEdge(edge.source, edge.target);
  });

  dagre.layout(dagreGraph);

  return nodes.map((node) => {
    const nodeWithPosition = dagreGraph.node(node.id);
    return {
      ...node,
      targetPosition: isHorizontal ? 'left' : 'top',
      sourcePosition: isHorizontal ? 'right' : 'bottom',
      position: {
        x: nodeWithPosition.x - nodeWidth / 2,
        y: nodeWithPosition.y - nodeHeight / 2,
      },
    };
  });
};

const OrganizationChart: React.FC<OrganizationChartProps> = ({ data }) => {
  const initialNodes: Node[] = [];
  const initialEdges: Edge[] = [];

  const processData = (
    department: Department,
    parentId: string | null = null,
    level: number = 0
  ) => {
    const id = department.name.replace(/\//g, '-');
    initialNodes.push({
      id,
      data: {
        label: (
          <div>
            <strong>{department.name}</strong>
            {department.users.map((user) => (
              <div key={user.id} className="text-sm">
                {user.name} ({user.role})
              </div>
            ))}
          </div>
        ),
      },
      position: { x: 0, y: 0 }, // Position will be set by dagre
      style: {
        width: nodeWidth,
        border: '1px solid #ddd',
        borderRadius: '5px',
        padding: '10px',
      },
    });

    if (parentId) {
      initialEdges.push({
        id: `${parentId}-${id}`,
        source: parentId,
        target: id,
        type: 'smoothstep',
        animated: true,
        markerEnd: {
          type: MarkerType.ArrowClosed,
        },
      });
    }

    department.children.forEach((child) =>
      processData(child, id, level + 1)
    );
  };

  processData(data);

  const { nodes: layoutedNodes, edges: layoutedEdges }: any = useMemo(() => {
    const nodes = getLayoutedElements(initialNodes, initialEdges);
    return { nodes, edges: initialEdges };
  }, [data]);

  const [nodes, setNodes, onNodesChange] = useNodesState(layoutedNodes);
  const [edges, setEdges, onEdgesChange] = useEdgesState(layoutedEdges);

  const onConnect = useCallback(
    (params: Edge | Connection) => setEdges((eds) => addEdge(params, eds)),
    [setEdges]
  );

  return (
    <div style={{ width: '100%', height: '600px' }}>
      <ReactFlow
        nodes={nodes}
        edges={edges}
        onNodesChange={onNodesChange}
        onEdgesChange={onEdgesChange}
        onConnect={onConnect}
        connectionLineType={ConnectionLineType.SmoothStep}
        fitView
      />
    </div>
  );
};

export default OrganizationChart;

//////////////// FILE: components/OrganizationStructure.tsx ////////////////

// components/OrganizationStructure.tsx

import { useState, useEffect } from 'react'
import { useAuth } from '@/components/AuthProvider'
import { User, Role } from '@prisma/client'
import { Button } from '@/components/ui/button'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { Alert, AlertDescription } from "@/components/ui/alert"
import { Steps, StepItem } from "@/components/custom/Steps"
import OrganizationChart from '@/components/OrganizationChart'
import CSVUploader from '@/components/CsvUploader'
import DataPreview from '@/components/DataPreview'
import UserTable from '@/components/UserTable'

type OrganizationUser = {
  organization: string;
  managerEmail: string;
  role: Role;
  email: string;
}

type Department = {
  name: string;
  users: User[];
  children: Department[];
}

enum UploadStep {
  UPLOAD,
  PREVIEW,
  COMPLETE
}

export default function OrganizationStructure() {
  const [users, setUsers] = useState<User[]>([])
  const [uploadError, setUploadError] = useState<string | null>(null)
  const [uploadSuccess, setUploadSuccess] = useState<string | null>(null)
  const [previewData, setPreviewData] = useState<OrganizationUser[]>([])
  const [currentStep, setCurrentStep] = useState<UploadStep>(UploadStep.UPLOAD)
  const [organizationData, setOrganizationData]: any = useState<Department | null>(null)
  const { user } = useAuth()

  useEffect(() => {
    fetchUsers()
    fetchOrganizationData()
  }, [])

  const fetchUsers = async () => {
    try {
      const response = await fetch('/api/users')
      if (!response.ok) {
        throw new Error('ユーザー情報の取得に失敗しました')
      }
      const data = await response.json()
      setUsers(data)
    } catch (error: any) {
      console.error('ユーザー情報の取得中にエラーが発生しました:', error)
      setUploadError('ユーザー情報の取得に失敗しました')
    }
  }

  const fetchOrganizationData = async () => {
    try {
      const response = await fetch('/api/organization/structure')
      if (!response.ok) {
        throw new Error('組織構造の取得に失敗しました')
      }
      const data = await response.json()
      setOrganizationData(data)
    } catch (error: any) {
      console.error('組織構造の取得中にエラーが発生しました:', error)
      setUploadError('組織構造の取得に失敗しました')
    }
  }

  const handleUploadSuccess = (data: OrganizationUser[]) => {
    setPreviewData(data)
    setUploadError(null)
    setUploadSuccess('ファイルが正常にアップロードされました。データを確認してください。')
    setCurrentStep(UploadStep.PREVIEW)
  }

  const handleConfirmUpload = async () => {
    try {
      const response = await fetch('/api/organization/confirm', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ data: previewData }),
      })

      const result = await response.json()

      if (response.ok) {
        setUploadSuccess('組織構造が正常に登録されました')
        setPreviewData([])
        fetchUsers()
        fetchOrganizationData()
        setCurrentStep(UploadStep.COMPLETE)
      } else {
        setUploadError(result.message || '登録に失敗しました')
      }
    } catch (error: any) {
      console.error('登録中にエラーが発生しました:', error)
      setUploadError('登録中にエラーが発生しました')
    }
  }

  const handleNewUpload = () => {
    setPreviewData([])
    setUploadError(null)
    setUploadSuccess(null)
    setCurrentStep(UploadStep.UPLOAD)
  }

  if (user?.role !== Role.ADMIN) {
    return null
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle>組織構造管理</CardTitle>
      </CardHeader>
      <CardContent>
        <Steps currentStep={currentStep} className="mb-8">
          <StepItem title="CSVアップロード" description="組織構造データをアップロード" />
          <StepItem title="データプレビュー" description="アップロードされたデータを確認" />
          <StepItem title="登録完了" description="データベースに反映" />
        </Steps>

        {uploadError && (
          <Alert variant="destructive" className="mb-4">
            <AlertDescription>{uploadError}</AlertDescription>
          </Alert>
        )}

        {uploadSuccess && (
          <Alert className="mb-4">
            <AlertDescription>{uploadSuccess}</AlertDescription>
          </Alert>
        )}

        {currentStep === UploadStep.UPLOAD && (
          <CSVUploader onUploadSuccess={handleUploadSuccess} />
        )}

        {currentStep === UploadStep.PREVIEW && (
          <DataPreview
            data={previewData}
            onConfirm={handleConfirmUpload}
            onCancel={handleNewUpload}
          />
        )}

        {currentStep === UploadStep.COMPLETE && (
          <div className="mt-4 space-y-4">
            <Alert>
              <AlertDescription>組織構造が正常に登録されました。新しいCSVをアップロードする場合は「新規アップロード」ボタンをクリックしてください。</AlertDescription>
            </Alert>
            <Button onClick={handleNewUpload}>新規アップロード</Button>
          </div>
        )}

        {organizationData && (
          <div className="mt-8">
            <h3 className="text-lg font-semibold mb-4">組織図</h3>
            <OrganizationChart data={organizationData} />
          </div>
        )}

        <UserTable users={users} />
      </CardContent>
    </Card>
  )
}

//////////////// FILE: components/PasswordChangeForm.tsx ////////////////

// components/PasswordChangeForm.tsx

import React, { useState } from 'react'
import { useAuth } from '@/components/AuthProvider'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Alert, AlertDescription } from "@/components/ui/alert"

const PASSWORD_MIN_LENGTH = 8

export default function PasswordChangeForm() {
  const [currentPassword, setCurrentPassword] = useState('')
  const [newPassword, setNewPassword] = useState('')
  const [confirmPassword, setConfirmPassword] = useState('')
  const [error, setError] = useState<string | null>(null)
  const [success, setSuccess] = useState<string | null>(null)
  const { user } = useAuth()

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    setError(null)
    setSuccess(null)

    if (newPassword !== confirmPassword) {
      setError('新しいパスワードと確認用パスワードが一致しません。')
      return
    }

    try {
      const response = await fetch('/api/auth/change-password', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ currentPassword, newPassword }),
      })

      const data = await response.json()

      if (response.ok) {
        setSuccess('パスワードが正常に変更されました。')
        setCurrentPassword('')
        setNewPassword('')
        setConfirmPassword('')
      } else {
        setError(data.message || 'パスワードの変更に失敗しました。')
      }
    } catch (error) {
      setError('パスワードの変更中にエラーが発生しました。ネットワーク接続を確認してください。')
    }
  }

  if (!user) {
    return null
  }

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <h2 className="text-lg font-semibold">パスワード変更</h2>
      {error && (
        <Alert variant="destructive">
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}
      {success && (
        <Alert>
          <AlertDescription>{success}</AlertDescription>
        </Alert>
      )}
      <div>
        <label htmlFor="currentPassword" className="block text-sm font-medium text-gray-700">
          現在のパスワード
        </label>
        <Input
          id="currentPassword"
          type="password"
          value={currentPassword}
          onChange={(e) => setCurrentPassword(e.target.value)}
          required
        />
      </div>
      <div>
        <label htmlFor="newPassword" className="block text-sm font-medium text-gray-700">
          新しいパスワード
        </label>
        <Input
          id="newPassword"
          type="password"
          value={newPassword}
          onChange={(e) => setNewPassword(e.target.value)}
          required
        />
      </div>
      <div>
        <label htmlFor="confirmPassword" className="block text-sm font-medium text-gray-700">
          新しいパスワード（確認）
        </label>
        <Input
          id="confirmPassword"
          type="password"
          value={confirmPassword}
          onChange={(e) => setConfirmPassword(e.target.value)}
          required
        />
      </div>
      <Button type="submit">パスワードを変更</Button>
    </form>
  )
}

//////////////// FILE: components/UserInfo.tsx ////////////////

import { useState, useEffect } from 'react'
import { useAuth } from './AuthProvider'
import { User } from '@prisma/client'
import { Card, CardContent, CardHeader, CardTitle, CardFooter } from '@/components/ui/card'
import { translateRole } from '@/lib/translations'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Alert, AlertDescription } from "@/components/ui/alert"
import PasswordChangeForm from './PasswordChangeForm'

export default function UserInfo() {
  const { user, updateUserInfo }: any = useAuth()
  const [userDetails, setUserDetails] = useState<User | null>(null)
  const [manager, setManager] = useState<User | null>(null)
  const [isEditing, setIsEditing] = useState(false)
  const [newName, setNewName] = useState('')
  const [error, setError] = useState<string | null>(null)
  const [showPasswordForm, setShowPasswordForm] = useState(false)

  useEffect(() => {
    if (user) {
      fetchUserDetails()
    }
  }, [user])

  const fetchUserDetails = async () => {
    if (!user) return;
    const response = await fetch(`/api/users/${user.id}`)
    if (response.ok) {
      const data = await response.json()
      setUserDetails(data)
      setNewName(data.name || '')
      if (data.managerId) {
        fetchManager(data.managerId)
      }
    }
  }

  const fetchManager = async (managerId: string) => {
    const response = await fetch(`/api/users/${managerId}`)
    if (response.ok) {
      const data = await response.json()
      setManager(data)
    }
  }

  const handleEdit = () => {
    setIsEditing(true)
    setNewName(userDetails?.name || '')
  }

  const handleCancel = () => {
    setIsEditing(false)
    setNewName(userDetails?.name || '')
    setError(null)
  }

  const handleSave = async () => {
    if (!userDetails) return

    try {
      const response = await fetch(`/api/users/${userDetails.id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name: newName.trim() || null }),
      })

      if (response.ok) {
        const updatedUser = await response.json()
        setUserDetails(updatedUser)
        setIsEditing(false)
        setError(null)
        updateUserInfo({ ...user, name: updatedUser.name })
      } else {
        const errorData = await response.json()
        setError(errorData.message || 'ユーザー情報の更新に失敗しました')
      }
    } catch (error: any) {
      console.error('Error updating user:', error)
      setError('ユーザー情報の更新中にエラーが発生しました')
    }
  }

  if (!userDetails) {
    return null
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle>ユーザー情報</CardTitle>
      </CardHeader>
      <CardContent>
        {error && (
          <Alert variant="destructive" className="mb-4">
            <AlertDescription>{error}</AlertDescription>
          </Alert>
        )}
        {isEditing ? (
          <div className="space-y-4">
            <div>
              <label htmlFor="name" className="block text-sm font-medium text-gray-700">名前</label>
              <Input
                id="name"
                value={newName}
                onChange={(e) => setNewName(e.target.value)}
                placeholder="新しい名前を入力"
                className="mt-1"
              />
            </div>
            <div className="space-x-2">
              <Button onClick={handleSave}>保存</Button>
              <Button variant="outline" onClick={handleCancel}>キャンセル</Button>
            </div>
          </div>
        ) : (
          <>
            <p><strong>名前:</strong> {userDetails.name || '未設定'}</p>
            <p><strong>メールアドレス:</strong> {userDetails.email}</p>
            <p><strong>役割:</strong> {translateRole(userDetails.role)}</p>
            <p><strong>部署:</strong> {userDetails.department || '未割当'}</p>
            <p><strong>マネージャー:</strong> {manager ? (manager.name || manager.email) : '未割当'}</p>
          </>
        )}
        {!isEditing && (
          <div className="mt-4 space-x-2">
            <Button onClick={handleEdit}>ユーザー情報を編集</Button>
            <Button onClick={() => setShowPasswordForm(!showPasswordForm)}>
              {showPasswordForm ? 'パスワード変更フォームを隠す' : 'パスワードを変更'}
            </Button>
          </div>
        )}
        {showPasswordForm && <PasswordChangeForm />}
      </CardContent>
    </Card>
  )
}

//////////////// FILE: components/UserTable.tsx ////////////////

// components/UserTable.tsx

import { User } from '@prisma/client'
import {
  Table,
  TableBody,
  TableCaption,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table"

type UserTableProps = {
  users: User[];
}

export default function UserTable({ users }: UserTableProps) {
  return (
    <div>
      <h3 className="text-lg font-semibold mt-8 mb-4">登録済みユーザー一覧</h3>
      <Table>
        <TableCaption>登録済みユーザー一覧</TableCaption>
        <TableHeader>
          <TableRow>
            <TableHead>名前</TableHead>
            <TableHead>メールアドレス</TableHead>
            <TableHead>役職（ロール）</TableHead>
            <TableHead>部署</TableHead>
            <TableHead>上司</TableHead>
          </TableRow>
        </TableHeader>
        <TableBody>
          {users.map((user: any) => (
            <TableRow key={user.id}>
              <TableCell>{user.name || '未設定'}</TableCell>
              <TableCell>{user.email}</TableCell>
              <TableCell>{user.role}</TableCell>
              <TableCell>{user.department || '未設定'}</TableCell>
              <TableCell>
                {user.manager
                  ? (user.manager.name || user.manager.email)
                  : '未設定'}
              </TableCell>
            </TableRow>
          ))}
        </TableBody>
      </Table>
    </div>
  )
}

//////////////// FILE: components/custom/FileInput.tsx ////////////////

// components/custom/FileInput.tsx

import React, { useRef, useState } from 'react'
import { Button } from "@/components/ui/button"

interface FileInputProps {
  onChange: (event: React.ChangeEvent<HTMLInputElement>) => void
  accept?: string
}

export const FileInput: React.FC<FileInputProps> = ({ onChange, accept }) => {
  const [fileName, setFileName] = useState<string | null>(null)
  const inputRef = useRef<HTMLInputElement>(null)

  const handleClick = () => {
    inputRef.current?.click()
  }

  const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0]
    if (file) {
      setFileName(file.name)
    } else {
      setFileName(null)
    }
    onChange(event)
  }

  return (
    <div className="flex items-center space-x-2">
      <Button type="button" onClick={handleClick}>
        CSVファイルを選択
      </Button>
      <input
        type="file"
        ref={inputRef}
        onChange={handleChange}
        accept={accept}
        className="hidden"
      />
      {fileName && <span className="text-sm text-gray-600">{fileName}</span>}
    </div>
  )
}

//////////////// FILE: components/custom/Steps.tsx ////////////////

// components/custom/Steps.tsx

import React from 'react'
import { cn } from "@/lib/utils"

interface StepItemProps {
  title: string
  description: string
}

export const StepItem: React.FC<StepItemProps> = ({ title, description }) => (
  <div className="text-center">
    <h3 className="font-semibold">{title}</h3>
    <p className="text-sm text-gray-600">{description}</p>
  </div>
)

interface StepsProps {
  currentStep: number
  className?: string
  children: React.ReactElement<StepItemProps>[]
}

export const Steps: React.FC<StepsProps> = ({ currentStep, className, children }) => {
  return (
    <div className={cn("flex justify-between items-start", className)}>
      {React.Children.map(children, (child, index) => (
        <div className={cn("flex flex-col items-center flex-1 relative", 
          { "text-blue-600": index === currentStep, "text-gray-400": index !== currentStep })}>
          <div className={cn("w-8 h-8 rounded-full flex justify-center items-center font-bold mb-2",
            { "bg-blue-600 text-white": index === currentStep, "bg-gray-200 text-gray-600": index !== currentStep })}>
            {index + 1}
          </div>
          {child}
          {index < children.length - 1 && (
            <div className={cn("absolute top-4 w-full h-0.5 -right-1/2", 
              { "bg-blue-600": index < currentStep, "bg-gray-200": index >= currentStep })} />
          )}
        </div>
      ))}
    </div>
  )
}

//////////////// FILE: components/ui/alert.tsx ////////////////

import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
))
Alert.displayName = "Alert"

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
))
AlertTitle.displayName = "AlertTitle"

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
))
AlertDescription.displayName = "AlertDescription"

export { Alert, AlertTitle, AlertDescription }


//////////////// FILE: components/ui/badge.tsx ////////////////

import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge, badgeVariants }


//////////////// FILE: components/ui/button.tsx ////////////////

import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }


//////////////// FILE: components/ui/card.tsx ////////////////

import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-lg border bg-card text-card-foreground shadow-sm",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }


//////////////// FILE: components/ui/input.tsx ////////////////

import * as React from "react"

import { cn } from "@/lib/utils"

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }


//////////////// FILE: components/ui/label.tsx ////////////////

"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }


//////////////// FILE: components/ui/select.tsx ////////////////

"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "@/lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>

    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}


//////////////// FILE: components/ui/table.tsx ////////////////

import * as React from "react"

import { cn } from "@/lib/utils"

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
))
Table.displayName = "Table"

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
))
TableHeader.displayName = "TableHeader"

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
))
TableBody.displayName = "TableBody"

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      className
    )}
    {...props}
  />
))
TableFooter.displayName = "TableFooter"

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className
    )}
    {...props}
  />
))
TableRow.displayName = "TableRow"

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0",
      className
    )}
    {...props}
  />
))
TableHead.displayName = "TableHead"

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn("p-4 align-middle [&:has([role=checkbox])]:pr-0", className)}
    {...props}
  />
))
TableCell.displayName = "TableCell"

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
))
TableCaption.displayName = "TableCaption"

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}


//////////////// FILE: components/ui/textarea.tsx ////////////////

import * as React from "react"

import { cn } from "@/lib/utils"

export interface TextareaProps
  extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
  ({ className, ...props }, ref) => {
    return (
      <textarea
        className={cn(
          "flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Textarea.displayName = "Textarea"

export { Textarea }


//////////////// FILE: docs/コミュニケーション機能を強化した目標設定プロセスのユーザーフロー図.mermaid ////////////////

graph TD
    A[社員: ログイン/登録] --> B[ダッシュボード表示]
    B --> C{ユーザーロール?}
    C -->|社員| D[目標リスト表示]
    C -->|マネージャー| E[目標レビューリスト表示]
    C -->|管理者| F[組織構造管理]

    D --> G[年・四半期選択]
    G --> H{目標存在?}
    H -->|No| I[新規目標設定]
    H -->|Yes| J[目標詳細表示]
    I --> K[目標入力/編集]
    K --> L[目標保存 - DRAFT]
    J --> M{目標状態?}
    M -->|DRAFT| N[編集]
    M -->|SUBMITTED| O[レビュー待ち]
    M -->|REJECTED/APPROVED| P[編集or再提出]
    N --> K
    P --> K
    L --> Q[Submit for Review]
    Q --> R[上司に通知]

    E --> S[部下の目標リスト]
    S --> T[目標レビュー]
    T --> U{承認?}
    U -->|Yes| V[目標承認]
    U -->|No| W[目標拒否]
    V --> X[フィードバック入力]
    W --> X
    X --> Y[社員に通知]
    Y --> J

    F --> Z[CSV ファイルアップロード]
    Z --> AA[CSV データ検証]
    AA --> AB{検証結果}
    AB -->|エラーあり| AC[エラー表示]
    AC --> Z
    AB -->|エラーなし| AD[検証結果確認]
    AD --> AE[一括登録実行]
    AE --> AF[登録完了通知]

    F --> AG[登録済み組織構造表示]
    AG --> AH[個別ユーザー編集]

    AI[認証システム] --> A
    AJ[ユーザー情報表示] --> B
    AJ --> AK[ユーザー名編集]
    AK --> AL[ユーザー名更新]
    AL --> AJ

    J --> AM[フィードバック履歴表示]
    AM --> AN[目標状態更新]
    AN --> J

//////////////// FILE: docs/要件定義書.md ////////////////

# 目標設定/評価システム要件定義書（更新版）

## 1. システム概要

### 1.1 背景
現行の目標設定/評価システムは煩雑であり、効果的な目標設定ツールとして機能していない。新システムの導入により、現行の課題を解消し、より効率的かつ効果的な目標設定/評価プロセスの実現を目指す。

### 1.2 目的
- 煩雑な目標設定/評価プロセスの簡素化
- 効果的な目標設定と公平な評価の実現
- ユーザーの行動変容を促進するシステムの構築
- リアルタイムなフィードバックとコミュニケーションの促進
- マネージャーと部下間の継続的な目標レビューと頻繁なフィードバックサイクルの実現

### 1.3 ターゲット
従業員数が数百名以上で、目標設定/評価プロセスが煩雑になっている企業

## 2. システム要件

### 2.1 機能要件

#### 2.1.1 認証機能
1. ユーザー登録機能（メールアドレスとパスワードによる登録）
2. ログイン機能
3. ログアウト機能
4. ユーザーロール管理（社員、マネージャー、管理者）
5. ユーザー名変更機能 (新規追加)
6. パスワード変更機能 (新規追加)
   - 現在ログインしているユーザーが自身のパスワードを変更できる
   - 現在のパスワードと新しいパスワードの入力を要求
   - パスワード変更の成功・失敗をユーザーに通知

#### 2.1.2 目標設定機能
1. 社員が具体的かつ行動変容につながる目標を設定できる機能
2. 目標の下書き保存機能
3. 目標の編集機能（DRAFT, REJECTED, APPROVED状態の場合）
4. 目標の削除機能
5. 目標の提出機能（上司へのレビュー依頼）
6. 目標一覧表示機能（年・四半期ごと）
7. 四半期ごとに1つの目標のみ設定可能

#### 2.1.3 目標レビュー機能
1. マネージャーによる部下の目標一覧表示機能
2. 目標の承認/拒否機能
3. フィードバック入力機能
4. 目標ステータス更新機能（承認済み、拒否）
5. 継続的な目標レビューサイクル機能
   - マネージャーが定期的に目標の進捗を確認できる機能
   - 部下が目標の進捗を随時更新できる機能
   - マネージャーと部下が目標について頻繁にコミュニケーションを取れる機能

#### 2.1.4 フィードバック機能
1. マネージャーから社員へのフィードバックを記録・表示する機能
2. 社員が受け取ったフィードバックを確認できる機能
3. フィードバックの履歴管理機能（最新のものから順に表示）
4. フィードバックに基づく目標の修正・更新機能
5. 承認/拒否された目標の再提出機能

#### 2.1.5 組織構造管理機能
1. ユーザー管理（役割別権限設定含む）
2. 組織構造管理
   a. CSV ファイルによる一括登録機能
      - CSV フォーマット: 組織, 役職（ロール）, メールアドレス
      - 組織階層は / で区切って表現
   b. アップロードされた CSV ファイルの検証機能
   c. 検証結果の表示と確認機能
   d. 確認後の一括登録実行機能
3. 登録済み組織構造の表示機能
4. 個別ユーザーの編集機能

#### 2.1.6 ダッシュボード機能
1. ユーザーロールに応じた情報表示
2. ユーザー情報表示
3. 目標進捗状況の可視化
4. 直近のフィードバックや目標更新の表示

### 2.2 非機能要件

#### 2.2.1 ユーザビリティ
1. シンプルで直感的なユーザーインターフェース
2. レスポンシブデザイン（PC、タブレット、スマートフォン対応）

#### 2.2.2 パフォーマンス
1. ページロード時間：3秒以内
2. 同時アクセスユーザー数：最大1000人

#### 2.2.3 セキュリティ
1. ユーザー認証（メールアドレスとパスワードによる認証）
2. データの暗号化（保存時および通信時）
3. アクセス制御（ロールベースのアクセス制御）

#### 2.2.4 拡張性
1. 将来的な機能追加に対応できる柔軟な設計
2. サードパーティ製品との連携を考慮したAPI設計

## 3. システム構成

### 3.1 フロントエンド
- Next.js (App Router)
- Tailwind CSS
- shadcn/ui

### 3.2 バックエンド
- Node.js (v20.16.0)
- Next.js API Routes

### 3.3 データベース
- Supabase (PostgreSQL)

### 3.4 ORM
- Prisma

### 3.5 認証
- Supabase Auth

## 4. 開発方針

### 4.1 開発手法
アジャイル開発手法を採用し、短いイテレーションで機能を実装・テスト・リリースする。

### 4.2 品質管理
- ユニットテスト、統合テスト、E2Eテストの実施
- コードレビューの徹底
- 継続的インテグレーション/継続的デリバリー（CI/CD）の導入

### 4.3 ドキュメント
- システム設計書
- APIドキュメント
- ユーザーマニュアル

## 5. 今後の拡張計画

1. 評価機能の強化
   - 目標に対する達成度評価機能
   - 評価結果の可視化機能
   - 評価会議の内容を記録・共有する機能

2. レポーティング機能の追加
   - 部署別、個人別の目標達成状況レポート
   - 評価結果の統計分析レポート

3. コミュニケーション機能の拡充
   - リアルタイムチャット機能
   - 定期的なチェックイン機能（1on1ミーティング支援）

これらの拡張計画は、ユーザーフィードバックと市場動向に基づいて優先順位付けし、段階的に実装していく予定です。

## 6. リスク管理

1. データセキュリティリスク
   - 対策：定期的なセキュリティ監査と脆弱性テストの実施
2. スケジュール遅延リスク
   - 対策：アジャイル開発手法の採用と定期的な進捗確認
3. ユーザー採用リスク
   - 対策：ユーザビリティテストの実施と段階的なロールアウト
4. データ整合性リスク
   - 対策：CSV アップロード時のデータ検証と、既存データとの整合性チェックの実装

以上が更新された要件定義書の概要となります。この内容を基に、システムの詳細設計と実装を継続して進めていきます。

//////////////// FILE: lib/prisma.ts ////////////////

import { PrismaClient } from '@prisma/client'

let prisma: PrismaClient

if (process.env.NODE_ENV === 'production') {
  prisma = new PrismaClient()
} else {
  if (!(global as any).prisma) {
    (global as any).prisma = new PrismaClient()
  }
  prisma = (global as any).prisma
}

export default prisma

//////////////// FILE: lib/supabase/client.ts ////////////////

import { createBrowserClient } from '@supabase/ssr'

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  )
}

//////////////// FILE: lib/supabase/middleware.ts ////////////////

import { createServerClient } from '@supabase/ssr'
import { NextResponse, type NextRequest } from 'next/server'

export async function updateSession(request: NextRequest) {
  let supabaseResponse = NextResponse.next({
    request,
  })

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return request.cookies.getAll()
        },
        setAll(cookiesToSet) {
          cookiesToSet.forEach(({ name, value, options }) => request.cookies.set(name, value))
          supabaseResponse = NextResponse.next({
            request,
          })
          cookiesToSet.forEach(({ name, value, options }) =>
            supabaseResponse.cookies.set(name, value, options)
          )
        },
      },
    }
  )

  // const {
  //   data: { user },
  // } = await supabase.auth.getUser()

  // if (
  //   !user &&
  //   !request.nextUrl.pathname.startsWith('/login') &&
  //   !request.nextUrl.pathname.startsWith('/auth')
  // ) {
  //   // no user, potentially respond by redirecting the user to the login page
  //   const url = request.nextUrl.clone()
  //   url.pathname = '/login'
  //   return NextResponse.redirect(url)
  // }

  return supabaseResponse
}

//////////////// FILE: lib/supabase/server.ts ////////////////

import { createServerClient, type CookieOptions } from '@supabase/ssr'
import { cookies } from 'next/headers'

export function createClient() {
  const cookieStore = cookies()

  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll()
        },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) =>
              cookieStore.set(name, value, options)
            )
          } catch {
            // The `setAll` method was called from a Server Component.
            // This can be ignored if you have middleware refreshing
            // user sessions.
          }
        },
      },
    }
  )
}

//////////////// FILE: lib/translations.ts ////////////////

// lib/translations.ts

export function translateRole(role: string): string {
  switch (role) {
    case 'EMPLOYEE':
      return '従業員';
    case 'MANAGER':
      return 'マネージャー';
    case 'ADMIN':
      return '管理者';
    default:
      return role;
  }
}

export function translateGoalStatus(status: string): string {
  switch (status) {
    case 'DRAFT':
      return '下書き';
    case 'SUBMITTED':
      return '申請中';
    case 'APPROVED':
      return '承認済み';
    case 'REJECTED':
      return '却下';
    default:
      return status;
  }
}

//////////////// FILE: lib/utils.ts ////////////////

import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}


//////////////// FILE: middleware.ts ////////////////

import { type NextRequest } from 'next/server'
import { updateSession } from '@/lib/supabase/middleware'

export async function middleware(request: NextRequest) {
  return await updateSession(request)
}

export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * Feel free to modify this pattern to include more paths.
     */
    '/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)',
  ],
}

//////////////// FILE: next-env.d.ts ////////////////

/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/basic-features/typescript for more information.


//////////////// FILE: next.config.mjs ////////////////

/** @type {import('next').NextConfig} */
export const nextConfig = {
  reactStrictMode: true,
  experimental: {
    appDir: true,
  },
  eslint: {
    // ビルド時に ESLint チェックを無効化
    ignoreDuringBuilds: true,
  },
}


//////////////// FILE: package.json ////////////////

{
  "name": "goal-setting-app",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@prisma/client": "^5.19.0",
    "@radix-ui/react-accordion": "^1.2.0",
    "@radix-ui/react-label": "^2.1.0",
    "@radix-ui/react-scroll-area": "^1.1.0",
    "@radix-ui/react-select": "^2.1.1",
    "@radix-ui/react-slot": "^1.1.0",
    "@supabase/ssr": "^0.5.1",
    "@supabase/supabase-js": "^2.45.2",
    "@types/dagre": "^0.7.52",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.1",
    "csv-parse": "^5.5.6",
    "csv-stringify": "^6.5.1",
    "dagre": "^0.8.5",
    "lucide-react": "^0.436.0",
    "next": "14.2.7",
    "react": "^18",
    "react-dom": "^18",
    "reactflow": "^11.11.4",
    "tailwind-merge": "^2.5.2",
    "tailwindcss-animate": "^1.0.7"
  },
  "devDependencies": {
    "@types/node": "^20.16.2",
    "@types/react": "^18.3.5",
    "@types/react-dom": "^18",
    "eslint": "^8",
    "eslint-config-next": "14.2.7",
    "postcss": "^8",
    "prisma": "^5.19.0",
    "tailwindcss": "^3.4.1",
    "typescript": "^5.5.4"
  }
}


//////////////// FILE: postcss.config.mjs ////////////////

/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
  },
};

export default config;


//////////////// FILE: prisma/migrations/20240830114122_init/migration.sql ////////////////

-- CreateTable
CREATE TABLE "User" (
    "id" TEXT NOT NULL,
    "email" TEXT NOT NULL,
    "name" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Goal" (
    "id" TEXT NOT NULL,
    "title" TEXT NOT NULL,
    "description" TEXT NOT NULL,
    "status" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "Goal_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Comment" (
    "id" TEXT NOT NULL,
    "content" TEXT NOT NULL,
    "goalId" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "Comment_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "User_email_key" ON "User"("email");

-- AddForeignKey
ALTER TABLE "Goal" ADD CONSTRAINT "Goal_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Comment" ADD CONSTRAINT "Comment_goalId_fkey" FOREIGN KEY ("goalId") REFERENCES "Goal"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Comment" ADD CONSTRAINT "Comment_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;


//////////////// FILE: prisma/migrations/20240902082841_add_user_role/migration.sql ////////////////

/*
  Warnings:

  - You are about to drop the `Comment` table. If the table is not empty, all the data it contains will be lost.

*/
-- CreateEnum
CREATE TYPE "Role" AS ENUM ('EMPLOYEE', 'MANAGER', 'ADMIN');

-- DropForeignKey
ALTER TABLE "Comment" DROP CONSTRAINT "Comment_goalId_fkey";

-- DropForeignKey
ALTER TABLE "Comment" DROP CONSTRAINT "Comment_userId_fkey";

-- AlterTable
ALTER TABLE "User" ADD COLUMN     "role" "Role" NOT NULL DEFAULT 'EMPLOYEE';

-- DropTable
DROP TABLE "Comment";


//////////////// FILE: prisma/migrations/20240902083449_add_goal_approval_flow/migration.sql ////////////////

/*
  Warnings:

  - The `status` column on the `Goal` table would be dropped and recreated. This will lead to data loss if there is data in the column.

*/
-- CreateEnum
CREATE TYPE "GoalStatus" AS ENUM ('DRAFT', 'SUBMITTED', 'APPROVED', 'REJECTED');

-- AlterTable
ALTER TABLE "Goal" ADD COLUMN     "feedback" TEXT,
ADD COLUMN     "managerId" TEXT,
DROP COLUMN "status",
ADD COLUMN     "status" "GoalStatus" NOT NULL DEFAULT 'DRAFT';

-- AddForeignKey
ALTER TABLE "Goal" ADD CONSTRAINT "Goal_managerId_fkey" FOREIGN KEY ("managerId") REFERENCES "User"("id") ON DELETE SET NULL ON UPDATE CASCADE;


//////////////// FILE: prisma/migrations/20240903123924_add_organization_structure/migration.sql ////////////////

-- AlterTable
ALTER TABLE "User" ADD COLUMN     "department" TEXT,
ADD COLUMN     "managerId" TEXT;

-- AddForeignKey
ALTER TABLE "User" ADD CONSTRAINT "User_managerId_fkey" FOREIGN KEY ("managerId") REFERENCES "User"("id") ON DELETE SET NULL ON UPDATE CASCADE;


//////////////// FILE: prisma/migrations/20240904110214_add_quarter_and_year_to_goals/migration.sql ////////////////

-- Step 1: Add nullable columns
ALTER TABLE "Goal" ADD COLUMN "quarter" INTEGER;
ALTER TABLE "Goal" ADD COLUMN "year" INTEGER;

-- Step 2: Set default values for existing goals
UPDATE "Goal"
SET "quarter" = EXTRACT(QUARTER FROM "createdAt"),
    "year" = EXTRACT(YEAR FROM "createdAt")
WHERE "quarter" IS NULL OR "year" IS NULL;

-- Step 3: Change columns to NOT NULL
ALTER TABLE "Goal" ALTER COLUMN "quarter" SET NOT NULL;
ALTER TABLE "Goal" ALTER COLUMN "year" SET NOT NULL;

-- Step 4: Add unique constraint (Commented out for now)
-- CREATE UNIQUE INDEX "Goal_userId_year_quarter_key" ON "Goal"("userId", "year", "quarter");

//////////////// FILE: prisma/migrations/20240904110452_manual_20240904200445/migration.sql ////////////////

/*
  Warnings:

  - A unique constraint covering the columns `[userId,year,quarter]` on the table `Goal` will be added. If there are existing duplicate values, this will fail.

*/
-- CreateIndex
CREATE UNIQUE INDEX "Goal_userId_year_quarter_key" ON "Goal"("userId", "year", "quarter");


//////////////// FILE: prisma/migrations/20240904115758_multi_feedbacks/migration.sql ////////////////

/*
  Warnings:

  - You are about to drop the column `feedback` on the `Goal` table. All the data in the column will be lost.

*/
-- AlterTable
ALTER TABLE "Goal" DROP COLUMN "feedback";

-- CreateTable
CREATE TABLE "Feedback" (
    "id" TEXT NOT NULL,
    "content" TEXT NOT NULL,
    "status" "GoalStatus" NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "goalId" TEXT NOT NULL,
    "userId" TEXT NOT NULL,

    CONSTRAINT "Feedback_pkey" PRIMARY KEY ("id")
);

-- AddForeignKey
ALTER TABLE "Feedback" ADD CONSTRAINT "Feedback_goalId_fkey" FOREIGN KEY ("goalId") REFERENCES "Goal"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Feedback" ADD CONSTRAINT "Feedback_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;


//////////////// FILE: prisma/migrations/20240904135546_update_goal_structure/migration.sql ////////////////

-- 既存のカラムを変更する前に、一時的なカラムを追加
ALTER TABLE "Goal" ADD COLUMN "temp_organizationGoal" TEXT;
ALTER TABLE "Goal" ADD COLUMN "temp_performanceRole" TEXT;
ALTER TABLE "Goal" ADD COLUMN "temp_performanceCriteria" TEXT;
ALTER TABLE "Goal" ADD COLUMN "temp_stretchVision" TEXT;
ALTER TABLE "Goal" ADD COLUMN "temp_stretchGap" TEXT;
ALTER TABLE "Goal" ADD COLUMN "temp_stretchAction" TEXT;
ALTER TABLE "Goal" ADD COLUMN "temp_stretchCriteria" TEXT;

-- 既存のデータを新しいカラムに移行（ここでは空の文字列を使用）
UPDATE "Goal" SET 
  "temp_organizationGoal" = '',
  "temp_performanceRole" = '',
  "temp_performanceCriteria" = '',
  "temp_stretchVision" = '',
  "temp_stretchGap" = '',
  "temp_stretchAction" = '',
  "temp_stretchCriteria" = '';

-- 既存のカラムを削除
ALTER TABLE "Goal" DROP COLUMN "title";
ALTER TABLE "Goal" DROP COLUMN "description";

-- 新しいカラムを追加し、一時的なカラムのデータを移行
ALTER TABLE "Goal" ADD COLUMN "organizationGoal" TEXT NOT NULL DEFAULT '';
ALTER TABLE "Goal" ADD COLUMN "performanceRole" TEXT NOT NULL DEFAULT '';
ALTER TABLE "Goal" ADD COLUMN "performanceCriteria" TEXT NOT NULL DEFAULT '';
ALTER TABLE "Goal" ADD COLUMN "stretchVision" TEXT NOT NULL DEFAULT '';
ALTER TABLE "Goal" ADD COLUMN "stretchGap" TEXT NOT NULL DEFAULT '';
ALTER TABLE "Goal" ADD COLUMN "stretchAction" TEXT NOT NULL DEFAULT '';
ALTER TABLE "Goal" ADD COLUMN "stretchCriteria" TEXT NOT NULL DEFAULT '';

UPDATE "Goal" SET 
  "organizationGoal" = "temp_organizationGoal",
  "performanceRole" = "temp_performanceRole",
  "performanceCriteria" = "temp_performanceCriteria",
  "stretchVision" = "temp_stretchVision",
  "stretchGap" = "temp_stretchGap",
  "stretchAction" = "temp_stretchAction",
  "stretchCriteria" = "temp_stretchCriteria";

-- 一時的なカラムを削除
ALTER TABLE "Goal" DROP COLUMN "temp_organizationGoal";
ALTER TABLE "Goal" DROP COLUMN "temp_performanceRole";
ALTER TABLE "Goal" DROP COLUMN "temp_performanceCriteria";
ALTER TABLE "Goal" DROP COLUMN "temp_stretchVision";
ALTER TABLE "Goal" DROP COLUMN "temp_stretchGap";
ALTER TABLE "Goal" DROP COLUMN "temp_stretchAction";
ALTER TABLE "Goal" DROP COLUMN "temp_stretchCriteria";

-- デフォルト値を削除
ALTER TABLE "Goal" ALTER COLUMN "organizationGoal" DROP DEFAULT;
ALTER TABLE "Goal" ALTER COLUMN "performanceRole" DROP DEFAULT;
ALTER TABLE "Goal" ALTER COLUMN "performanceCriteria" DROP DEFAULT;
ALTER TABLE "Goal" ALTER COLUMN "stretchVision" DROP DEFAULT;
ALTER TABLE "Goal" ALTER COLUMN "stretchGap" DROP DEFAULT;
ALTER TABLE "Goal" ALTER COLUMN "stretchAction" DROP DEFAULT;
ALTER TABLE "Goal" ALTER COLUMN "stretchCriteria" DROP DEFAULT;

//////////////// FILE: prisma/migrations/migration_lock.toml ////////////////

# Please do not edit this file manually
# It should be added in your version-control system (i.e. Git)
provider = "postgresql"

//////////////// FILE: prisma/schema.prisma ////////////////

// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String   @id @default(cuid())
  email         String   @unique
  name          String?
  role          Role     @default(EMPLOYEE)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  managerId     String?
  manager       User?    @relation("ManagerToEmployee", fields: [managerId], references: [id])
  employees     User[]   @relation("ManagerToEmployee")
  department    String?
  goals         Goal[]   @relation("UserGoals")
  managedGoals  Goal[]   @relation("ManagerGoals")
  feedbacks     Feedback[]
}

model Goal {
  id                  String     @id @default(cuid())
  organizationGoal    String
  performanceRole     String
  performanceCriteria String
  stretchVision       String
  stretchGap          String
  stretchAction       String
  stretchCriteria     String
  status              GoalStatus @default(DRAFT)
  userId              String
  user                User       @relation("UserGoals", fields: [userId], references: [id])
  managerId           String?
  manager             User?      @relation("ManagerGoals", fields: [managerId], references: [id])
  quarter             Int
  year                Int
  createdAt           DateTime   @default(now())
  updatedAt           DateTime   @updatedAt
  feedbacks           Feedback[]

  @@unique([userId, year, quarter])
}

model Feedback {
  id        String   @id @default(cuid())
  content   String
  status    GoalStatus
  createdAt DateTime @default(now())
  goalId    String
  goal      Goal     @relation(fields: [goalId], references: [id])
  userId    String
  user      User     @relation(fields: [userId], references: [id])
}

enum Role {
  EMPLOYEE
  MANAGER
  ADMIN
}

enum GoalStatus {
  DRAFT
  SUBMITTED
  APPROVED
  REJECTED
}

//////////////// FILE: public/next.svg ////////////////

<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>

//////////////// FILE: public/vercel.svg ////////////////

<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 283 64"><path fill="black" d="M141 16c-11 0-19 7-19 18s9 18 20 18c7 0 13-3 16-7l-7-5c-2 3-6 4-9 4-5 0-9-3-10-7h28v-3c0-11-8-18-19-18zm-9 15c1-4 4-7 9-7s8 3 9 7h-18zm117-15c-11 0-19 7-19 18s9 18 20 18c6 0 12-3 16-7l-8-5c-2 3-5 4-8 4-5 0-9-3-11-7h28l1-3c0-11-8-18-19-18zm-10 15c2-4 5-7 10-7s8 3 9 7h-19zm-39 3c0 6 4 10 10 10 4 0 7-2 9-5l8 5c-3 5-9 8-17 8-11 0-19-7-19-18s8-18 19-18c8 0 14 3 17 8l-8 5c-2-3-5-5-9-5-6 0-10 4-10 10zm83-29v46h-9V5h9zM37 0l37 64H0L37 0zm92 5-27 48L74 5h10l18 30 17-30h10zm59 12v10l-3-1c-6 0-10 4-10 10v15h-9V17h9v9c0-5 6-9 13-9z"/></svg>

//////////////// FILE: tailwind.config.ts ////////////////

import type { Config } from "tailwindcss"

const config = {
  darkMode: ["class"],
  content: [
    './pages/**/*.{ts,tsx}',
    './components/**/*.{ts,tsx}',
    './app/**/*.{ts,tsx}',
    './src/**/*.{ts,tsx}',
	],
  prefix: "",
  theme: {
  	container: {
  		center: true,
  		padding: '2rem',
  		screens: {
  			'2xl': '1400px'
  		}
  	},
  	extend: {
  		colors: {
  			border: 'hsl(var(--border))',
  			input: 'hsl(var(--input))',
  			ring: 'hsl(var(--ring))',
  			background: 'hsl(var(--background))',
  			foreground: 'hsl(var(--foreground))',
  			primary: {
  				DEFAULT: 'hsl(var(--primary))',
  				foreground: 'hsl(var(--primary-foreground))'
  			},
  			secondary: {
  				DEFAULT: 'hsl(var(--secondary))',
  				foreground: 'hsl(var(--secondary-foreground))'
  			},
  			destructive: {
  				DEFAULT: 'hsl(var(--destructive))',
  				foreground: 'hsl(var(--destructive-foreground))'
  			},
  			muted: {
  				DEFAULT: 'hsl(var(--muted))',
  				foreground: 'hsl(var(--muted-foreground))'
  			},
  			accent: {
  				DEFAULT: 'hsl(var(--accent))',
  				foreground: 'hsl(var(--accent-foreground))'
  			},
  			popover: {
  				DEFAULT: 'hsl(var(--popover))',
  				foreground: 'hsl(var(--popover-foreground))'
  			},
  			card: {
  				DEFAULT: 'hsl(var(--card))',
  				foreground: 'hsl(var(--card-foreground))'
  			}
  		},
  		borderRadius: {
  			lg: 'var(--radius)',
  			md: 'calc(var(--radius) - 2px)',
  			sm: 'calc(var(--radius) - 4px)'
  		},
  		keyframes: {
  			'accordion-down': {
  				from: {
  					height: '0'
  				},
  				to: {
  					height: 'var(--radix-accordion-content-height)'
  				}
  			},
  			'accordion-up': {
  				from: {
  					height: 'var(--radix-accordion-content-height)'
  				},
  				to: {
  					height: '0'
  				}
  			}
  		},
  		animation: {
  			'accordion-down': 'accordion-down 0.2s ease-out',
  			'accordion-up': 'accordion-up 0.2s ease-out'
  		}
  	}
  },
  plugins: [require("tailwindcss-animate")],
} satisfies Config

export default config

//////////////// FILE: tsconfig.json ////////////////

{
  "compilerOptions": {
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}


//////////////// FILE: types/index.ts ////////////////

export interface User {
  id: string
  email: string
  name?: string
}

export interface Goal {
  id: string
  title: string
  description: string
  status: string
  userId: string
  createdAt: Date
  updatedAt: Date
}

export interface Comment {
  id: string
  content: string
  goalId: string
  userId: string
  createdAt: Date
  updatedAt: Date
}

